<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>example1-10</title>
</head>

<body>
    <script>

        function sayHi1() {
            console.log(name);
            console.log(age);
            var name = 'ldh';
            let age = 21;
        }
        //sayHi1();     // undefined ReferenceError

        console.log("--------02-------");
        for (var i = 0; i < 3; i++) {
            setTimeout(() => console.log(i), 1);
        }
        for (let i = 0; i < 3; i++) {
            setTimeout(() => console.log(i), 1);
        }
        //3 3 3 和 0 1 2
        // let声明有块级作用域，而var无，for循环里面是异步函数
        // var定义时，for循环已执行完，var的值会覆盖最后一个值，而let每个值会对应一块区域

        console.log("--------03-------");
        const shape3 = {
            radius: 10,
            diameter() {
                return this.radius * 2;
            },
            permeter: () => 2 * Math.PI * this.radius,
        }
        shape3.diameter();     // 20   对象中的this 指向当前对象
        shape3.permeter();     // NaN  箭头函数自己没有this，里面的this会指向window

        console.log("--------04-------");
        console.log(+true);     // 1 单独一个 + ，会转成 number
        console.log(!"ldh");   // false 单独一个 ! ,会转换成Boolean值
        // 注： js中假值有5个：undefined、null、0、空字符串、NaN

        console.log("--------05-------");
        const bird5 = {
            size: 'small',
        }
        const mouse5 = {
            name: 'mickey',
            small: true
        }
        // console.log(mouse.bird.size);    // Uncaught TypeError
        console.log(mouse5[bird5.size]);   // true
        console.log(mouse5[bird5['size']]);  // true
        // 注： 获取对象的属性值两种方式： 对象.属性   对象["属性"]
        // 对象.属性 当当前对象没有该属性时这样写会报错
        // 对象["属性"] 可动态获取

        console.log("--------06-------");
        let c6 = { greeting: "Hey!" }
        let d6;
        d6 = c6;
        c6.greeting = "Hello";
        console.log(d6.greeting);   // Hello   
        // 对象（引用类型）的赋值为浅复制，直接复制引用地址
        // 注：基础数据类型直接存储在栈中，直接存储值，复制是会复制值（另开辟一块内存空间）
        // 引用数据类型存储在堆中，在栈中存储其在堆中的地址，不可以直接对堆进行操作

        console.log("--------07-------");
        let a7 = 3;
        let b7 = new Number(3);
        let c7 = 3;
        console.log(a7 == b7);   // true
        console.log(a7 === b7);  // false
        console.log(b7 === c7);  // false
        console.log(a7 === c7);  // true
        // == 只比较值相等， === 同时比较值和数据类型是否相等
        // new Number() 返回的实例是对象，类型是object，而 a7 和 c7 是number类型

        console.log("--------08-------");
        class Chameleon8 {
            static colorChange(newColor) {
                this.newColor = newColor;
                return this.newColor;
            }
            constructor({ newColor = 'green' } = {}) {   //这构造会指定默认的属性值
                this.newColor = newColor;
            }
        }
        const freddie8 = new Chameleon8({ newColor: 'purple' });

        const a8 = new Chameleon8();
        console.log(a8.newColor);          // green
        console.log(freddie8.newColor);    // purple
        console.log(Chameleon8.colorChange(a8.newColor));    // green
        // console.log(freddie8.colorChange('orange'));  // TypeError
        // 对象不能访问类的静态方法，只能通过 类名.方法 调用

        console.log("--------09-------");
        let greeting9;
        greetingn9 = {};
        // 'use strict';
        console.log(greetingn9);   // {}
        // 注： 严格模式下会报错 ReferenceError: greetingn9 is not defined

        console.log("--------10-------");
        function bark10() {
            console.log("woof!");
        }
        bark10.animal = "dog";   // 正常执行（因为函数也是对象）
        console.log(bark10.animal);  // dog
        // 注：js中万物皆对象
    </script>
</body>

</html>