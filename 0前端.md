## **HTML/CSS**

### HTML5新特性

​	相比 H4多了 10 个新特性，但不支持 ie8 及以下版本的浏览器。https://www.cnblogs.com/binguo666/p/10928907.html

1. 语义标签。header（文档头部区域）、footer（文档尾部区域）、nav（文档导航）、section（文档中的节）等
2. 增强型表单。**新增了 input 输入特性**，改善更好的输入控制和验证。color（选取颜色）、date（选取日期）、search（用于搜索域）等。**新增了5 个表单元素**：datalist（输入数据时可看到下拉列表）、progress（进度条）、meter（刻度值，计量温度、重量等）、keygen（用于验证用户的方法，生成一个公私钥）、output（用于不同类型的输出）。**新增表单属性**：placeholder（默认提示文字）、required（输入内容是否可以为空）、autofocus（页面加载时自动获得焦点）。
3. 视频和音频。audio / video   controls属性提供添加播放、暂停和音量控件。autoplay控制自动播放。
4. Canvas绘图
5. SVG绘图。可伸缩矢量图形，使用 XML 格式定义图形。**优势**：可伸缩，且在放大的时候质量不会不会下降；可以通过编译器进行创建修改；SVG图像可以脚本话或压缩。**svg/canvas区别**：svg不依赖分辨率而canvas依赖，svg支持事件处理器而canvas不支持，Ssvg是基于 XML 的，意味着可以操作 DOM，渲染速度较慢，适合大型渲染区域的应用程序，canvas文字呈现功能比较简单，能够以 png 或 jpg 格式保存结果图像
6. 地理定位。navigator.geolocation.getCurrentPosition() 来获取用户的位置。
7. 拖放API。<div draggable="true"></div> 拖放是标准中的一部分，任何元素都可以拖放。属性有 ondragstart（拖动开始，在拖动操作开始时执行脚本）、ondrag（只要脚本在被拖动就运行脚本）、ondragenter（当元素被拖动到一个合法的防止目标上时，执行脚本）、ondrop（拖动结束，将被拖动元素放在目标元素内时运行脚本）、ondragend（在拖动操作结束时运行脚本）。
8. WebWorker。可以通过加载一个脚本文件，进而创建一个独立工作的线程，在主线程之外运行。Web Worker的基本原理就是在当前javascript的主线程中，使用Worker类加载一个javascript文件来开辟一个新的线程，起到互不阻塞执行的效果，并且提供主线程和新县城之间数据交换的接口：postMessage、onmessage。
9. WebStorage。
10. WebSocket。

### **CSS3新特性**

​	https://juejin.cn/post/6844903486618861575

​	==1.新增属性选择器==。[attr^=val] 、[atttr$=val] 、[attr*=val] （以val 开头/结尾 或包含的属性）。nth-child(n) 第 n 个子元素、last-child等等；

​	==2.transition / Transform / Animation==

​		**transition**：在当元素从一种样式变换为另一种样式时为元素添加效果，而不用使用 flash 或 JavaScript。有以下属性：transition-property（应用过渡属性的CSS名称）、transition-duration（完成过渡效果所需时间）、transition-delay（过渡开始时间，即延迟）、transition-timing-function（过渡效果的时间曲线，默认ease（加速度先增加后减小），还有linear(线性 )）、transition（简写属性）

​		**transform**：给元素应用各种 2D 和 3D 转换，实现对元素的旋转、缩放、移动和倾斜等操作。translate（位移）、scale（比例缩放）、rotate（旋转）、skew(x-angle, y-angle)（沿着 X 和 Y 轴的 2D 倾斜转换）

​		**animation**：@keyframes name { from: xxx, to:xxx  或  50%:xxx, 100%:xxx } 实现动画效果。transition只能设置过渡过程中（头和尾）变化效果，animation 可以控制的更加精细，可以指定过渡过程中每一个时间段执行的动作。

​	==3.边框==。CSS3 新增 3 个边框属性，分别是 **border-radius**（边框弧度）、**box-shadow**（元素添加阴影 x偏移量、y偏移量、模糊半径、阴影颜色）、**border-image**（用图片来绘制边框）。

​	==4.背景==。**background-clip**：确定背景画区（border-box:背景从border开始显示，padding-box， content-box、no-clip：默认，等同于border-box）、**background-origin**：确定背景位置（与background-position联合使用，border-box:从border开始计算background-position，padding-box，content-box）、**background-size**：调整背景图片大小，主要用于设定图片本身（contain:缩放图片来完全装入背景区，可能背景区部分空白；cover:缩放图片来完全覆盖背景区，可能背景图片部分看不见（这两个都不会改变宽高比）；100px 100px 或 50% 50% : 会改变宽高比到指定的大小）、**background-break**：CSS3 中元素可以被分成几个独立的盒子，该属性用来控制背景怎样在不同的盒子中显示（continuous：默认值，忽略盒子之间的距离，像依然是一个整体一样；bounding-box：把盒子之间的距离计算在内；each-box：为每个盒子单独设置背景）。

​	==5.文字效果==。**word-wrap**：允许强制文本换行，意味着会对单词进行拆分（break-word）；**text-overflow**：设置当当前行超过指定容器的边界时如何显示（clip：默认值，在内容区域的极限处截断文本，ellipsis：用一个省略号"..."）；**text-shadow**：向文本应用阴影（水平阴影 垂直阴影 模糊距离 阴影颜色）；text-decoration：对文字的更深层次的渲染（text-fill-color：文字内部填充颜色；text-stroke-color：文字边界填充颜色；text-stroke-width：文字边界宽度）

​	==6.渐变==。实现渐变效果。**linear-gradient**（线性渐变）；**radial-gradient**（径向渐变）

​	==7.@font-face==。使用创建的自定义字体

​	==8.多列布局==。**column-count**：规定元素应该被分割的列数；**column-gap**：规定列之间的间隔；**column-rule**：设置列之间的宽度、样式和颜色规则。

​	==9.用户界面==。新的用户界面属性包括重设元素尺寸、和尺寸以及轮廓等等。**resize**：规定用户是否可以调整元素尺寸（overflow、auto、hidden、scroll）；**box-sizing**：（content-box：w3c盒模型，content+padding+border构成元素宽高，border-box：设置宽高之后大小不变，不会被撑大）；**outline-offset**：与outline搭配使用，设置outline与一个元素边缘或边框之间的间隙。

### **Doctype**

​	H5使用方式： <!DOCTYPE html> 。DOCTYPE标签用来声明文档类型，告诉标准通用标记语言解析器，应该使用什么样的文档类型定义（DTD）来解析文档。

### **meta标签**

​	https://juejin.cn/post/6844904083296370702#heading-1

​	meta标签提供 HTML 文档的元数据。它不会显示在页面上，但是对于机器是可读的，告诉这个机器怎么去解析这个页面。可用于浏览器（如何显示内容或重新加载页面，可以添加服务器发送到浏览器的 http 头部内容），搜索引擎（关键词），或其他 web 服务。

1. 必须属性：content，不是说 meta 标签里必须有 content，而是当有 http-equiv 或 name 属性的时候，一定要有 content 属性对它进行说明。

2. 可选属性：W3C中有三个，http-equiv、name 和 scheme（不常用）。charest用来声明文档使用的字符编码，主要用来解决乱码问题，必须写在第一行。**http-equiv** 属性是添加到 http 头部内容，对一些自定义或需要额外添加的 http 头部内容，需要发送到浏览器中，就可以使用这个属性。name 属性是用于给浏览器进行解析。name 属性常用于解决浏览器的兼容性问题（前提是浏览器能够解析写进去的name属性）。

   ```html
   // charest 有两种写法
   <meta charest="utf-8" />
   <meta http-equiv="Content-Type" content="text/html; charest=utf-8" />
   
   // 不想使用 js 重定向，可以像如下用 http 头部来控制。页面加入如下标签之后，5秒钟后会跳转到指定页面
   <meta http-equiv="Refresh" content="5;url=http://www.baidu.com" />
   
   // 告诉浏览器用 webkit 内核进行解析，前提是浏览器有 webkit 内核
   <meta name="renderer" content="webkit" />
   ```

### **margin负值**

1. margin-top为负值不会增加高度，只会产生向上位移；
2. margin-bottom为负值不会产生位移，会减少自身的供css读取的高度；
3. margin-left/right 负值会改变浮动元素的显示位置。

### **flex布局 （弹性布局）**

任何一个容器都可以 flex 布局，不论块、行内元素。父元素上添加 display: flex;

父元素设置为 flex 布局之后，子元素的 float、clear和vertical-align属性将失效。

#### **父项属性**

1. ==flex-direction==    设置主轴及排列方向。

   row：（默认）主轴为 X 轴， 左 -> 右；

   row-reverse：主轴为 X 轴， 右 -> 左；

   column： 主轴为 Y 轴， 上 -> 下；

   column-reverse：主轴为 Y 轴， 下 -> 上；

2. ==justify-content==    定义了项目在主轴上的对齐方式。

   flex-start （默认值）从头部开始，若主轴为 X 轴，则从左至右； flex-end：从尾部开始；

   center：沿主轴居中对齐；  space-around：平分剩余空间；

   space-between：先两边贴边，再平分剩余空间。

3. ==flex-wrap==    子元素是否换行 （默认不换行）

   nowrap：（默认）不换行；  wrap：换行； wrap-reverse：换行且从末往前进行显示。

4. ==align-items==   设置子元素在侧轴上的排列方式 （默认是 Y 轴） （该子项在单行时使用）

   flex-start：从上到下；  flex-end： 从下到上；  center：挤在一起居中（垂直居中）；

   strech：（默认）拉伸。注：子元素给高度就不会有效果，不然子元素高度会和父元素一样高。

5. ==align-content==   子元素有多行时在侧轴上的排列方式。注：只能用于子元素多行的情况，否则无效果。

   flex-start：侧轴头部开始排列；  flex-end：尾部开始；  center：侧轴居中显示；

   space-around：侧轴上平分剩余空间；  space-between：侧轴上先分布两头，再平分剩余空间；

   stretch：子项元素平分父元素高度。

6. ==flex-flow==   flex-direction 和 flex-wrap 的复合写法。

#### **子项属性**

1. ==flex==      是flex-grow、flex-shrink、flex-basis 的复合写法。默认： 0 1 auto。
2. ==flex-grow==   定义子项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。
3. ==flex-shrink==    定义子项目的放大比例，默认为1，即如果剩余空间不足，该项目会缩小。
4. ==flex-basis==    定义了在分配多余空间之前，项目占据的主轴空间。默认为 auto，即项目本来的大小。设为固定值，则大小为固定值大小。
5. ==align-self==   控制子项目自己在侧轴上的排列方式，允许单个子项目有与别的项目不一样的对齐方式。可覆盖 align-items 属性。默认值为 auto，表示继承父元素的align-items，如果没有父元素，则等同于 stretch。
6. ==order==   定义子项目的排列顺序。数值越小，排列越靠前，默认是 0。

### **水平居中、垂直水平居中**

1.水平居中

```css
margin: auto;
```

​		如果是float 的 div，在该div的父级 div 加一个 display:inline-block，父级的父级使用 text-align。

2.水平垂直居中（三种方式，不包括 flex、grid布局的方法）

```css
/* 三种方式分别以三个子元素来表示，全部使用定位来实现 */
.father {
    position: relative;
    height: 200px;
    width: 200px
}
/* 将定位中的四个方位全设为0，再 margin: auto
	此方法参见 CSS世界 P96、97	
*/
.son1 {
    position: absolute;
    height: 50px;
    width: 60px;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}
/* 方法2、3 相似，都是用left、top的百分比来设置，
	但这两个定位是以子盒子的左上角为参考点的，故还需要往回调一点，
	方法3的优点在于不需要知道子盒子的宽高。
*/
.son2 {
    position: absolute;
    height: 50px;
    width: 60px;
    left: 50%;
    top: 50%;
    margin-left: -30px;
    margin-right: -25px;
}
.son3 {
    position: absolute;
    height: 50px;
    width: 60px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, 50%);
}
```

### **两栏布局（左侧/右侧定宽，main 适应剩余宽度）**

1.浮动（左/右浮动，main 区域用margin-left/right 隔开左/右盒子的宽度）

```css
.aside {
    float: left;
    width: 200px;
    height: 200px;
}
.main {
    height: 200px;
    margin-left: 200px;
}
```

2.定位（左/右绝对定位，main 区域用margin-left/right 隔开左/右盒子的宽度。绝对定位会脱离标准流，不占用原来位置。）

```css
.aside {
    position: absolute;
    width: 200px;
    height: 200px;
}
.main {
    height: 200px;
    margin-left: 200px;
}
```

### **语法**

CSS 的核心功能是将 CSS 属性设定为特定的值。一个属性与值的键值对被称为**声明**（declaration）。

```
color: red;
```

而如果将一个或者多个声明用 `{}` 包裹起来后，那就组成了一个**声明块**（declaration block）。

```
{
    color: red;
    text-align: center;
}
```

声明块如果需要作用到对应的 HTML 元素，那还需要加上**选择器**。选择器和声明块组成了**CSS 规则集**（CSS ruleset），常简称为 CSS 规则。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlROP0Y73jMWjAuxBKFzQnPiahDe3lRC6wLFeTFG9xG7cE3TQRWKVPJ35w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
span {
    color: red;
    text-align: center;
}
```

> 规则集中最后一条声明可以省略分号，但是并不建议这么做，因为容易出错。

CSS 中的**注释**：

```
/* 单行注释 */

/*
    多行
    注释
*/
```

在 CSS 文件中，除了注释、CSS 规则集以及 @规则 外，定义的一些别的东西都将被浏览器忽略。

### @规则

CSS 规则是样式表的主体，通常样式表会包括大量的规则列表。但有时候也需要在样式表中包括其他的一些信息，比如字符集，导入其它的外部样式表，字体等，这些需要专门的语句表示。

而 @规则 就是这样的语句。CSS 里包含了以下 @规则：

- @namespace 告诉 CSS 引擎必须考虑XML命名空间。
- @media 如果满足媒体查询的条件则条件规则组里的规则生效。
- @page描述打印文档时布局的变化.
- @font-face 描述将下载的外部的字体。
- @keyframes 描述 CSS 动画的关键帧。
- @document 如果文档样式表满足给定条件则条件规则组里的规则生效。 (推延至 CSS Level 4 规范)

除了以上这几个之外，下面还将对几个比较生涩的 @规则 进行介绍。

#### @charset

**\@charset**[1] 用于定义样式表使用的字符集。它必须是样式表中的第一个元素。如果有多个 `@charset` 被声明，只有第一个会被使用，而且不能在HTML元素或HTML页面的 `<style>` 元素内使用。

注意：值必须是双引号包裹，且和

```
@charset "UTF-8";
```

平时写样式文件都没写 @charset 规则，那这个 CSS 文件到底是用的什么字符编码的呢？

某个样式表文件到底用的是什么字符编码，浏览器有一套识别顺序（优先级由高到低）：

- 文件开头的 **Byte order mark**[2] 字符值，不过一般编辑器并不能看到文件头里的 BOM 值；

- HTTP 响应头里的 `content-type` 字段包含的 `charset` 所指定的值，比如：

  ```
  Content-Type: text/css; charset=utf-8
  ```

- CSS 文件头里定义的 @charset 规则里指定的字符编码；

- `<link>` 标签里的 charset 属性，该条已在 HTML5 中废除；

- 默认是 `UTF-8`。

#### @import

**\@import**[3] 用于告诉 CSS 引擎引入一个外部样式表。

link 和 @import 都能导入一个样式文件，它们有什么区别嘛？

- link 是 HTML 标签，除了能导入 CSS 外，还能导入别的资源，比如图片、脚本和字体等；而 @import 是 CSS 的语法，只能用来导入 CSS；
- link 导入的样式会在页面加载时同时加载，@import 导入的样式需等页面加载完成后再加载；
- link 没有兼容性问题，@import 不兼容 ie5 以下；
- link 可以通过 JS 操作 DOM 动态引入样式表改变样式，而@import不可以。

#### @supports

**\@supports**[4] 用于查询特定的 CSS 是否生效，可以结合 not、and 和 or 操作符进行后续的操作。

```
/* 如果支持自定义属性，则把 body 颜色设置为变量 varName 指定的颜色 */
@supports (--foo: green) {
    body {
        color: var(--varName);
    }
}
```

### 层叠性

层叠样式表，这里的层叠怎么理解呢？其实它是 CSS 中的核心特性之一，用于合并来自多个源的属性值的算法。比如说针对某个 HTML 标签，有许多的 CSS 声明都能作用到的时候，那最后谁应该起作用呢？层叠性说的大概就是这个。

针对不同源的样式，将按照如下的顺序进行层叠，越往下优先级越高：

- 用户代理样式表中的声明(例如，浏览器的默认样式，在没有设置其他样式时使用)。
- 用户样式表中的常规声明(由用户设置的自定义样式。由于 Chrome 在很早的时候就放弃了用户样式表的功能，所以这里将不再考虑它的排序。)。
- 作者样式表中的常规声明(这些是我们 Web 开发人员设置的样式)。
- 作者样式表中的 !important 声明。
- 用户样式表中的 !important 声明S。

理解层叠性的时候需要结合 CSS 选择器的优先级以及继承性来理解。比如针对同一个选择器，定义在后面的声明会覆盖前面的；作者定义的样式会比默认继承的样式优先级更高。

### 选择器

CSS 选择器无疑是其核心之一，对于基础选择器以及一些常用伪类必须掌握。下面列出了常用的选择器。 想要获取更多选择器的用法可以看 **MDN CSS Selectors**[5]。

#### 基础选择器

- 标签选择器：`h1`
- 类选择器：`.checked`
- ID 选择器：`#picker`
- 通配选择器：`*`

**属性选择器**

- `[attr]`：指定属性的元素；
- `[attr=val]`：属性等于指定值的元素；
- `[attr*=val]`：属性包含指定值的元素；
- `[attr^=val]` ：属性以指定值开头的元素；
- `[attr$=val]`：属性以指定值结尾的元素；
- `[attr~=val]`：属性包含指定值(完整单词)的元素(不推荐使用)；
- `[attr|=val]`：属性以指定值(完整单词)开头的元素(不推荐使用)；

#### 组合选择器

- 相邻兄弟选择器：`A + B`
- 普通兄弟选择器：`A ~ B`
- 子选择器：`A > B`
- 后代选择器：`A B`

#### 伪类

**条件伪类**

- `:lang()`：基于元素语言来匹配页面元素；
- `:dir()`：匹配特定文字书写方向的元素；
- `:has()`：匹配包含指定元素的元素；
- `:is()`：匹配指定选择器列表里的元素；
- `:not()`：用来匹配不符合一组选择器的元素；

**行为伪类**

- `:active`：鼠标激活的元素；
- `:hover`： 鼠标悬浮的元素；
- `::selection`：鼠标选中的元素；

**状态伪类**

- `:target`：当前锚点的元素；
- `:link`：未访问的链接元素；
- `:visited`：已访问的链接元素；
- `:focus`：输入聚焦的表单元素；
- `:required`：输入必填的表单元素；
- `:valid`：输入合法的表单元素；
- `:invalid`：输入非法的表单元素；
- `:in-range`：输入范围以内的表单元素；
- `:out-of-range`：输入范围以外的表单元素；
- `:checked`：选项选中的表单元素；
- `:optional`：选项可选的表单元素；
- `:enabled`：事件启用的表单元素；
- `:disabled`：事件禁用的表单元素；
- `:read-only`：只读的表单元素；
- `:read-write`：可读可写的表单元素；
- `:blank`：输入为空的表单元素；
- `:current()`：浏览中的元素；
- `:past()`：已浏览的元素；
- `:future()`：未浏览的元素；

**结构伪类**

- `:root`：文档的根元素；
- `:empty`：无子元素的元素；
- `:first-letter`：元素的首字母；
- `:first-line`：元素的首行；
- `:nth-child(n)`：元素中指定顺序索引的元素；
- `:nth-last-child(n)`：元素中指定逆序索引的元素；；
- `:first-child` ：元素中为首的元素；
- `:last-child` ：元素中为尾的元素；
- `:only-child`：父元素仅有该元素的元素；
- `:nth-of-type(n)` ：标签中指定顺序索引的标签；
- `:nth-last-of-type(n)`：标签中指定逆序索引的标签；
- `:first-of-type` ：标签中为首的标签；
- `:last-of-type`：标签中为尾标签；
- `:only-of-type`：父元素仅有该标签的标签；

#### 伪元素

- `::before`：在元素前插入内容；
- `::after`：在元素后插入内容；

伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。主要区别是微元素生成了一个实际的元素

### 优先级

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRh4hFibfFXaZrwGBUMwEl0mMBZzvaMptUpMiaFIGauOicbQiafVyX3213ug/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

优先级就是分配给指定的 CSS 声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。为了记忆，可以把权重分成如下几个等级，数值越大的权重越高：

- 10000：!important；
- 01000：内联样式；
- 00100：ID 选择器；
- 00010：类选择器、伪类选择器、属性选择器；
- 00001：元素选择器、伪元素选择器；
- 00000：通配选择器、后代选择器、兄弟选择器；

可以看到内联样式（通过元素中 style 属性定义的样式）的优先级大于任何选择器；而给属性值加上 `!important` 又可以把优先级提至最高，就是因为它的优先级最高，所以需要谨慎使用它，以下有些使用注意事项：

- 一定要优先考虑使用样式规则的优先级来解决问题而不是 !important；
- 只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important；
- 永远不要在你的插件中使用 !important；
- 永远不要在全站范围的 CSS 代码中使用 !important；

### 继承性

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/zPh0erYjkib2owcKuRPGMy93fs1vehWlR3GP731UCicNSPZrc4TpXWzrsnD6kgvlEdRXbFoiaJ1DsnI6vRF9ibAkWA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在 CSS 中有一个很重要的特性就是子元素会继承父元素对应属性计算后的值。比如页面根元素 html 的文本颜色默认是黑色的，页面中的所有其他元素都将继承这个颜色，当申明了如下样式后，H1 文本将变成橙色。

```
body {    color: orange;}h1 {    color: inherit;}
```

设想一下，如果 CSS 中不存在继承性，那么我们就需要为不同文本的标签都设置一下 color，这样一来的后果就是 CSS 的文件大小就会无限增大。

CSS 属性很多，但并不是所有的属性默认都是能继承父元素对应属性的，那哪些属性存在默认继承的行为呢？一定是那些不会影响到页面布局的属性，可以分为如下几类：

- 字体相关：`font-family`、`font-style`、`font-size`、`font-weight` 等；
- 文本相关：`text-align`、`text-indent`、`text-decoration`、`text-shadow`、`letter-spacing`、`word-spacing`、`white-space`、`line-height`、`color` 等；
- 列表相关：`list-style`、`list-style-image`、`list-style-type`、`list-style-position` 等；
- 其他属性：`visibility`、`cursor` 等；

对于其他默认不继承的属性也可以通过以下几个属性值来控制继承行为：

- `inherit`：继承父元素对应属性的计算值；
- `initial`：应用该属性的默认值，比如 color 的默认值是 `#000`；
- `unset`：如果属性是默认可以继承的，则取 `inherit` 的效果，否则同 `initial`；
- `revert`：效果等同于 `unset`，兼容性差。

### 文档流

在 CSS 的世界中，会把内容按照从左到右、从上到下的顺序进行排列显示。正常情况下会把页面分割成一行一行的显示，而每行又可能由多列组成，所以从视觉上看起来就是从上到下从左到右，而这就是 CSS 中的流式布局，又叫文档流。文档流就像水一样，能够自适应所在的容器，一般它有如下几个特性：

- 块级元素默认会占满整行，所以多个块级盒子之间是从上到下排列的；
- 内联元素默认会在一行里一列一列的排布，当一行放不下的时候，会自动切换到下一行继续按照列排布；

**如何脱离文档流呢？**

脱流文档流指节点脱流正常文档流后，在正常文档流中的其他节点将忽略该节点并填补其原先空间。文档一旦脱流，计算其父节点高度时不会将其高度纳入，脱流节点不占据空间。有两种方式可以让元素脱离文档流：浮动和定位。

- 使用浮动（float）会将元素脱离文档流，移动到容器左/右侧边界或者是另一个浮动元素旁边，该浮动元素之前占用的空间将被别的元素填补，另外浮动之后所占用的区域不会和别的元素之间发生重叠；
- 使用绝对定位（`position: absolute;`）或者固定定位（`position: fixed;`）也会使得元素脱离文档流，且空出来的位置将自动被后续节点填补。

### 盒模型

在 CSS 中任何元素都可以看成是一个盒子，而一个盒子是由 4 部分组成的：内容（content）、内边距（padding）、边框（border）和外边距（margin）。

盒模型有 2 种：标准盒模型和 IE 盒模型，本别是由 W3C 和 IExplore 制定的标准。

如果给某个元素设置如下样式：

```
.box {    width: 200px;    height: 200px;    padding: 10px;    border: 1px solid #eee;    margin: 10px;}
```

标准盒模型认为：盒子的实际尺寸 = 内容（设置的宽/高） + 内边距 + 边框

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRBfRUscrsmp2dN7lCxWQdibaDLjiaiagaLTcnGF2w8ISpIsvEvNqDDKQibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

所以 `.box` 元素内容的宽度就为 `200px`，而实际的宽度则是 `width` + `padding-left` + `padding-right` + `border-left-width` + `border-right-width` = 200 + 10 + 10 + 1 + 1 = 222。

IE 盒模型认为：盒子的实际尺寸 = 设置的宽/高 = 内容 + 内边距 + 边框

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlR4JyAibhbmr3nibferUOibqlPjfiblqVZNKic6eFtmYnicW5PvqriaqvNsicsEA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

`.box` 元素所占用的实际宽度为 `200px`，而内容的真实宽度则是 `width` - `padding-left`- `padding-right` - `border-left-width` - `border-right-width` = 200 - 10 - 10 - 1 - 1 = 178。

现在高版本的浏览器基本上默认都是使用标准盒模型，而像 IE6 这种老古董才是默认使用 IE 盒模型的。

在 CSS3 中新增了一个属性 `box-sizing`，允许开发者来指定盒子使用什么标准，它有 2 个值：

- `content-box`：标准盒模型；
- `border-box`：IE 盒模型；

### 视觉格式化模型

视觉格式化模型（Visual formatting model）是用来处理和在视觉媒体上显示文档时使用的计算规则。CSS 中一切皆盒子，而视觉格式化模型简单来理解就是规定这些盒子应该怎么样放置到页面中去，这个模型在计算的时候会依赖到很多的因素，比如：盒子尺寸、盒子类型、定位方案（是浮动还是定位）、兄弟元素或者子元素以及一些别的因素。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/zPh0erYjkib2owcKuRPGMy93fs1vehWlRVxYzrrPicoHAPNbzw6lPdpOfYeQmMAc8tYLrOl6xpclpftfDjwicvowQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)Visual formatting model

从上图中可以看到视觉格式化模型涉及到的内容很多，有兴趣深入研究的可以结合上图看这个 W3C 的文档 **Visual formatting model**[6]。所以这里就简单介绍下盒子类型。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlR41IgVR7Rv0Y5FYibEQfTN5fiaJLAh5Io4pccVSuQlq71c2Ew2vvEo7FQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

盒子类型由 display 决定，同时给一个元素设置 display 后，将会决定这个盒子的 2 个显示类型（display type）：

- outer display type（对外显示）：决定了该元素本身是如何布局的，即参与何种格式化上下文；
- inner display type（对内显示）：其实就相当于把该元素当成了容器，规定了其内部子元素是如何布局的，参与何种格式化上下文；

#### outer display type

对外显示方面，盒子类型可以分成 2 类：block-level box（块级盒子） 和 inline-level box（行内级盒子）。

依据上图可以列出都有哪些块级和行内级盒子：

- 块级盒子：display 为 block、list-item、table、flex、grid、flow-root 等；
- 行内级盒子：display 为 inline、inline-block、inline-table 等；

所有块级盒子都会参与 BFC，呈现垂直排列；而所有行内级盒子都参会 IFC，呈现水平排列。

除此之外，block、inline 和 inline-block 还有什么更具体的区别呢？

**block**

- 占满一行，默认继承父元素的宽度；多个块元素将从上到下进行排列；
- 设置 width/height 将会生效；
- 设置 padding 和 margin 将会生效；

**inline**

- 不会占满一行，宽度随着内容而变化；多个 inline 元素将按照从左到右的顺序在一行里排列显示，如果一行显示不下，则自动换行；
- 设置 width/height 将不会生效；
- 设置竖直方向上的 padding 和 margin 将不会生效；

**inline-block**

- 是行内块元素，不单独占满一行，可以看成是能够在一行里进行左右排列的块元素；
- 设置 width/height 将会生效；
- 设置 padding 和 margin 将会生效；

#### inner display type

对内方面，其实就是把元素当成了容器，里面包裹着文本或者其他子元素。container box 的类型依据 display 的值不同，分为 4 种：

- block container：建立 BFC 或者 IFC；
- flex container：建立 FFC；
- grid container：建立 GFC;
- ruby container：接触不多，不做介绍。

值得一提的是如果把 img 这种替换元素（replaced element）申明为 block 是不会产生 container box 的，因为替换元素比如 img 设计的初衷就仅仅是通过 src 把内容替换成图片，完全没考虑过会把它当成容器。

### 格式化上下文

格式化上下文（Formatting Context）是 CSS2.1 规范中的一个概念，大概说的是页面中的一块渲染区域，规定了渲染区域内部的子元素是如何排版以及相互作用的。

不同类型的盒子有不同格式化上下文，大概有这 4 类：

- BFC (Block Formatting Context) 块级格式化上下文；
- IFC (Inline Formatting Context) 行内格式化上下文；
- FFC (Flex Formatting Context) 弹性格式化上下文；
- GFC (Grid Formatting Context) 格栅格式化上下文；

其中 BFC 和 IFC 在 CSS 中扮演着非常重要的角色，因为它们直接影响了网页布局，所以需要深入理解其原理。

#### BFC

块格式化上下文，它是一个独立的渲染区域，只有块级盒子参与，它规定了内部的块级盒子如何布局，并且与这个区域外部毫不相干。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlROiaK9ic79ax1uuvmJHsCauDYjPghK4ibk5s2IvaxbNAJJWmvbyc803MYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)图来源于 yachen168

**BFC 渲染规则**

- 内部的盒子会在垂直方向，一个接一个地放置；
- 盒子垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻盒子的 margin 会发生重叠；
- 每个元素的 margin 的左边，与包含块 border 的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此；
- BFC 的区域不会与 float 盒子重叠；
- BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
- 计算 BFC 的高度时，浮动元素也参与计算。

**如何创建 BFC？**

- 根元素：html
- 非溢出的可见元素：overflow 不为 visible
- 设置浮动：float 属性不为 none
- 设置定位：position 为 absolute 或 fixed
- 定义成块级的非块级元素：display: inline-block/table-cell/table-caption/flex/inline-flex/grid/inline-grid

**BFC 应用场景**

1、 自适应两栏布局

应用原理：BFC 的区域不会和浮动区域重叠，所以就可以把侧边栏固定宽度且左浮动，而对右侧内容触发 BFC，使得它的宽度自适应该行剩余宽度。

![图片](https://mmbiz.qpic.cn/mmbiz_gif/zPh0erYjkib2owcKuRPGMy93fs1vehWlRLLnK3EBlK3RJMFfbEqomOCiayTc6Cm09BAn2oGGIu1ibDQ75tPZvibJdQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)

```html
<div class="layout">
	<div class="aside">
		aside
	</div>
    <div class="main">
    	main
    </div>
</div>
<style>
    .aside {    
    	float: left;    
    	width: 100px;
    }
    .main {
    	<!-- 触发 BFC --> 
    	overflow: auto;
  	}
</style>
```

2、清除内部浮动

浮动造成的问题就是父元素高度坍塌，所以清除浮动需要解决的问题就是让父元素的高度恢复正常。而用 BFC 清除浮动的原理就是：计算 BFC 的高度时，浮动元素也参与计算。只要触发父元素的 BFC 即可。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRfMYiaZzYicmHa7VdBicsRhGxKzpjYVRuw5Mibhg8YGRtXbBchs5rJzNb9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
.parent {    overflow: hidden;}
```

3、 防止垂直 margin 合并

BFC 渲染原理之一：同一个 BFC 下的垂直 margin 会发生合并。所以如果让 2 个元素不在同一个 BFC 中即可阻止垂直 margin 合并。那如何让 2 个相邻的兄弟元素不在同一个 BFC 中呢？可以给其中一个元素外面包裹一层，然后触发其包裹层的 BFC，这样一来 2 个元素就不会在同一个 BFC 中了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRhagTEjTzZpLLsTAoF9pGh8ibtmnGuicf07BQFw8hh7nwgAnWzIwmuSVg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```html
<div class="layout">
	<div class="a">
		a
	</div>    
<div class="contain-b">
<div class="b">
	<div>
   		b
	</div>
</div>
.demo3 .a,.demo3 .b {
    border: 1px solid #999; 
    margin: 10px;
    }
.contain-b {
    overflow: hidden;
    }
```

针对以上 3 个 示例 ，可以结合这个 **BFC 应用示例**[7] 配合观看更佳。

#### IFC

IFC 的形成条件非常简单，块级元素中仅包含内联级别元素，需要注意的是当IFC中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRT7GAJmyyLxoS40TarvCayXYtpdXBNwg0YzN70c4vXOFXzfaFbEP8GQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**IFC 渲染规则**

- 子元素在水平方向上一个接一个排列，在垂直方向上将以容器顶部开始向下排列；
- 节点无法声明宽高，其中 margin 和 padding 在水平方向有效在垂直方向无效；
- 节点在垂直方向上以不同形式对齐；
- 能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的线盒（line box）。线盒的宽度是由包含块（containing box）和与其中的浮动来决定；
- IFC 中的 line box 一般左右边贴紧其包含块，但 float 元素会优先排列。
- IFC 中的 line box 高度由 line-height 计算规则来确定，同个 IFC 下的多个 line box 高度可能会不同；
- 当内联级盒子的总宽度少于包含它们的 line box 时，其水平渲染规则由 text-align 属性值来决定；
- 当一个内联盒子超过父元素的宽度时，它会被分割成多盒子，这些盒子分布在多个 line box 中。如果子元素未设置强制换行的情况下，inline box 将不可被分割，将会溢出父元素。

针对如上的 IFC 渲染规则，你是不是可以分析下下面这段代码的 IFC 环境是怎么样的呢？

```
<p>It can get <strong>very complicated</storng> once you start looking into it.</p>
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRjhWVSISFialE0wic80NliaD36UGy29RWvuER6u6q4kDJEdDxzbqvBtxuQ/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

对应上面这样一串 HTML 分析如下：

- p 标签是一个 block container，对内将产生一个 IFC；
- 由于一行没办法显示完全，所以产生了 2 个线盒（line box）；线盒的宽度就继承了 p 的宽度；高度是由里面的内联盒子的 line-height 决定；
- It can get：匿名的内联盒子；
- very complicated：strong 标签产生的内联盒子；
- once you start：匿名的内联盒子；
- looking into it.：匿名的内联盒子。

**IFC 应用场景**

- 水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。
- 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中。

偷个懒，demo 和图我就不做了。

### 层叠上下文

在电脑显示屏幕上的显示的页面其实是一个三维的空间，水平方向是 X 轴，竖直方向是 Y 轴，而屏幕到眼睛的方向可以看成是 Z 轴。众 HTML 元素依据自己定义的属性的优先级在 Z 轴上按照一定的顺序排开，而这其实就是层叠上下文所要描述的东西。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRmvOKBUddlggOjK8ibxBIkWjfLkonCKneicjAFGLhK8kk07PXbqPY9KnQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)-w566

我们对层叠上下文的第一印象可能要来源于 z-index，认为它的值越大，距离屏幕观察者就越近，那么层叠等级就越高，事实确实是这样的，但层叠上下文的内容远非仅仅如此：

- z-index 能够在层叠上下文中对元素的堆叠顺序其作用是必须配合定位才可以；
- 除了 z-index 之外，一个元素在 Z 轴上的显示顺序还受层叠等级和层叠顺序影响；

在看层叠等级和层叠顺序之前，我们先来看下如何产生一个层叠上下文，特定的 HTML 元素或者 CSS 属性产生层叠上下文，MDN 中给出了这么一个列表，符合以下任一条件的元素都会产生层叠上下文：

- html 文档根元素

- 声明 position: absolute/relative 且 z-index 值不为 auto 的元素；

- 声明 position: fixed/sticky 的元素；

- flex 容器的子元素，且 z-index 值不为 auto；

- grid 容器的子元素，且 z-index 值不为 auto；

- opacity 属性值小于 1 的元素；

- mix-blend-mode 属性值不为 normal 的元素；

- 以下任意属性值不为 none 的元素：

- - transform
  - filter
  - perspective
  - clip-path
  - mask / mask-image / mask-border

- isolation 属性值为 isolate 的元素；

- -webkit-overflow-scrolling 属性值为 touch 的元素；

- will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；

- contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。

**层叠等级**

层叠等级指节点在三维空间 Z 轴上的上下顺序。它分两种情况：

- 在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在 Z 轴上的上下顺序；
- 在其他普通元素中，它描述定义的是这些普通元素在 Z 轴上的上下顺序；

普通节点的层叠等级优先由其所在的层叠上下文决定，层叠等级的比较只有在当前层叠上下文中才有意义，脱离当前层叠上下文的比较就变得无意义了。

**层叠顺序**

在同一个层叠上下文中如果有多个元素，那么他们之间的层叠顺序是怎么样的呢？

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlR6YxCXwnDETbSExIia9j9a0Q13NeNCCzDPkOUGEL9IzgSN6IFX0KffNw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

以下这个列表越往下层叠优先级越高，视觉上的效果就是越容易被用户看到（不会被其他元素覆盖）：

- 层叠上下文的 border 和 background
- z-index < 0 的子节点
- 标准流内块级非定位的子节点
- 浮动非定位的子节点
- 标准流内行内非定位的子节点
- z-index: auto/0 的子节点
- z-index > 0的子节点

**如何比较两个元素的层叠等级？**

- 在同一个层叠上下文中，比较两个元素就是按照上图的介绍的层叠顺序进行比较。
- 如果不在同一个层叠上下文中的时候，那就需要比较两个元素分别所处的层叠上下文的等级。
- 如果两个元素都在同一个层叠上下文，且层叠顺序相同，则在 HTML 中定义越后面的层叠等级越高。

### 值和单位

CSS 的声明是由属性和值组成的，而值的类型有许多种：

- 数值：长度值 ，用于指定例如元素 width、border-width、font-size 等属性的值；
- 百分比：可以用于指定尺寸或长度，例如取决于父容器的 width、height 或默认的 font-size；
- 颜色：用于指定 background-color、color 等；
- 坐标位置：以屏幕的左上角为坐标原点定位元素的位置，比如常见的 background-position、top、right、bottom 和 left 等属性；
- 函数：用于指定资源路径或背景图片的渐变，比如 url()、linear-gradient() 等；

而还有些值是需要带单位的，比如 width: 100px，这里的 px 就是表示长度的单位，长度单位除了 px 外，比较常用的还有 em、rem、vw/vh 等。那他们有什么区别呢？又应该在什么时候使用它们呢？

#### px

屏幕分辨率是指在屏幕的横纵方向上的像素点数量，比如分辨率 1920×1080 意味着水平方向含有 1920 个像素数，垂直方向含有 1080 个像素数。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRWcMRxpdLyhy0HIpwibiaRl7XSt8zq6XI0xrna7849iczBqxHI50RRp78w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

而 px 表示的是 CSS 中的像素，在 CSS 中它是绝对的长度单位，也是最基础的单位，其他长度单位会自动被浏览器换算成 px。但是对于设备而言，它其实又是相对的长度单位，比如宽高都为 2px，在正常的屏幕下，其实就是 4 个像素点，而在设备像素比(devicePixelRatio) 为 2 的 Retina 屏幕下，它就有 16 个像素点。所以屏幕尺寸一致的情况下，屏幕分辨率越高，显示效果就越细腻。

讲到这里，还有一些相关的概念需要理清下：

**设备像素（Device pixels）**

设备屏幕的物理像素，表示的是屏幕的横纵有多少像素点；和屏幕分辨率是差不多的意思。

**设备像素比（DPR）**

设备像素比表示 1 个 CSS 像素等于几个物理像素。

计算公式：DPR = 物理像素数 / 逻辑像素数；

在浏览器中可以通过 window.devicePixelRatio 来获取当前屏幕的 DPR。

**像素密度（DPI/PPI）**

像素密度也叫显示密度或者屏幕密度，缩写为 DPI(Dots Per Inch) 或者 PPI(Pixel Per Inch)。从技术角度说，PPI 只存在于计算机显示领域，而 DPI 只出现于打印或印刷领域。

计算公式：像素密度 = 屏幕对角线的像素尺寸 / 物理尺寸

比如，对于分辨率为 750 * 1334 的 iPhone 6 来说，它的像素密度为：

```
Math.sqrt(750 * 750 + 1334 * 1334) / 4.7 = 326ppi
```

**设备独立像素（DIP）**

DIP 是特别针对 Android设备而衍生出来的，原因是安卓屏幕的尺寸繁多，因此为了显示能尽量和设备无关，而提出的这个概念。它是基于屏幕密度而计算的，认为当屏幕密度是 160 的时候，px = DIP。

计算公式：dip = px * 160 / dpi

#### em

em 是 CSS 中的相对长度单位中的一个。居然是相对的，那它到底是相对的谁呢？它有 2 层意思：

- 在 font-size 中使用是相对于**父元素**的 font-size 大小，比如父元素 font-size: 16px，当给子元素指定 font-size: 2em 的时候，经过计算后它的字体大小会是 32px；
- 在其他属性中使用是相对于自身的字体大小，如 width/height/padding/margin 等；

我们都知道每个浏览器都会给 HTML 根元素 html 设置一个默认的 font-size，而这个值通常是 16px。这也就是为什么 1em = 16px 的原因所在了。

em 在计算的时候是会层层计算的，比如：

```
<div>    <p></p></div>div { font-size: 2em; }p { font-size: 2em; }
```

对于如上一个结构的 HTML，由于根元素 html 的字体大小是 16px，所以 p 标签最终计算出来后的字体大小会是 16 * 2 * 2 = 64px

#### rem

rem(root em) 和 em 一样，也是一个相对长度单位，不过 rem 相对的是 HTML 的根元素 html。

rem 由于是基于 html 的 font-size 来计算，所以通常用于自适应网站或者 H5 中。

比如在做 H5 的时候，前端通常会让 UI 给 750px 宽的设计图，而在开发的时候可以基于 iPhone X 的尺寸 375px * 812px 来写页面，这样一来的话，就可以用下面的 JS 依据当前页面的视口宽度自动计算出根元素 html 的基准 font-size 是多少。

```
(function (doc, win) {    var docEl = doc.documentElement,        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',        psdWidth = 750,  // 设计图宽度        recalc = function () {            var clientWidth = docEl.clientWidth;            if ( !clientWidth ) return;            if ( clientWidth >= 640 ) {                docEl.style.fontSize = 200 * ( 640 / psdWidth ) + 'px';            } else {                docEl.style.fontSize = 200 * ( clientWidth / psdWidth ) + 'px';            }        };    if ( !doc.addEventListener ) return;    // 绑定事件的时候最好配合防抖函数    win.addEventListener( resizeEvt, debounce(recalc, 1000), false );    doc.addEventListener( 'DOMContentLoaded', recalc, false );        function debounce(func, wait) {        var timeout;        return function () {            var context = this;            var args = arguments;            clearTimeout(timeout)            timeout = setTimeout(function(){                func.apply(context, args)            }, wait);        }    }})(document, window);
```

比如当视口是 375px 的时候，经过计算 html 的 font-size 会是 100px，这样有什么好处呢？好处就是方便写样式，比如从设计图量出来的 header 高度是 50px 的，那我们写样式的时候就可以直接写：

```
header {    height: 0.5rem;}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRoD4b44aFANWekJ3icxIkxe1F4ibTNLyKzw0cPektIw2rd6Tn5AjWtc3Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

每个从设计图量出来的尺寸只要除于 100 即可得到当前元素的 rem 值，都不用经过计算，非常方便。偷偷告诉你，如果你把上面那串计算 html 标签 font-size 的 JS 代码中的 200 替换成 2，那在计算 rem 的时候就不需要除于 100 了，从设计图量出多大 px，就直接写多少个 rem。

#### vw/vh

vw 和 vh 分别是相对于屏幕视口宽度和高度而言的长度单位：

- 1vw = 视口宽度均分成 100 份中 1 份的长度；
- 1vh = 视口高度均分成 100 份中 1 份的长度；

在 JS 中 100vw = window.innerWidth，100vh = window.innerHeight。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/zPh0erYjkib2owcKuRPGMy93fs1vehWlR2jPyeKlNw6WE4pKnSicJxdbRXiaO30PJVMztDDAiaJdx9aGKOt0U3vlpA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

vw/vh 的出现使得多了一种写自适应布局的方案，开发者不再局限于 rem 了。

相对视口的单位，除了 vw/vh 外，还有 vmin 和 vmax：

- vmin：取 vw 和 vh 中值较小的；
- vmax：取 vw 和 vh 中值较大的；

### 颜色体系

CSS 中用于表示颜色的值种类繁多，足够构成一个体系，所以这里就专门拿出一个小节来讲解它。

根据 **CSS 颜色草案**[8] 中提到的颜色值类型，大概可以把它们分为这几类：

- 颜色关键字
- transparent 关键字
- currentColor 关键字
- RGB 颜色
- HSL 颜色

#### 颜色关键字

颜色关键字（color keywords）是不区分大小写的标识符，它表示一个具体的颜色，比如 white（白），黑（black）等；

可接受的关键字列表在CSS的演变过程中发生了改变：

- CSS 标准 1 只接受 16 个基本颜色，称为 VGA 颜色，因为它们来源于 VGA 显卡所显示的颜色集合而被称为 VGA colors （视频图形阵列色彩）。
- CSS 标准 2 增加了 orange 关键字。
- 从一开始，浏览器接受其它的颜色，由于一些早期浏览器是 X11 应用程序，这些颜色大多数是 X11 命名的颜色列表，虽然有一点不同。SVG 1.0 是首个正式定义这些关键字的标准；CSS 色彩标准 3 也正式定义了这些关键字。它们经常被称作扩展的颜色关键字， X11 颜色或 SVG 颜色 。
- CSS 颜色标准 4 添加可 rebeccapurple 关键字来纪念 web 先锋 Eric Meyer。

如下这张图是 16 个基础色，又叫 VGA 颜色。截止到目前为止 CSS 颜色关键字总共有 146 个，这里可以查看 **完整的色彩关键字列表**[9]。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRrCzqXh5BEd3ZFRqJ3z05F8Czicxk1FcC2mEm59gL6SJ5TlicmGLHWzvQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)VGA 颜色

需要注意的是如果声明的时候的颜色关键字是错误的，浏览器会忽略它。

#### transparent 关键字

transparent 关键字表示一个完全透明的颜色，即该颜色看上去将是背景色。从技术上说，它是带有 alpha 通道为最小值的黑色，是 rgba(0,0,0,0) 的简写。

透明关键字有什么应用场景呢？

**实现三角形**

下面这个图是用 4 条边框填充的正方形，看懂了它你大概就知道该如何用 CSS 写三角形了。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRVAR9P9slDiaFtawRhGKLpOQRYHialphfoqNEicPIVqq2pUAaMASUcEozA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
div {    border-top-color: #ffc107;    border-right-color: #00bcd4;    border-bottom-color: #e26b6b;    border-left-color: #cc7cda;    border-width: 50px;    border-style: solid;}
```

用 transparent 实现三角形的原理：

- 首先宽高必须是 0px，通过边框的粗细来填充内容；
- 那条边需要就要加上颜色，而不需要的边则用 transparent；
- 想要什么样姿势的三角形，完全由上下左右 4 条边的中有颜色的边和透明的边的位置决定；
- 等腰三角形：设置一条边有颜色，然后紧挨着的 2 边是透明，且宽度是有颜色边的一半；直角三角形：设置一条边有颜色，然后紧挨着的任何一边透明即可。

看下示例：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRIOib2tUzgeHshqZohW9UXuRjzlGKo53hmSpxWqU06dDT62RYO9G3WlA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**增大点击区域**

常常在移动端的时候点击的按钮的区域特别小，但是由于现实效果又不太好把它做大，所以常用的一个手段就是通过透明的边框来增大按钮的点击区域：

```
.btn {    border: 5px solid transparent;}
```

#### currentColor 关键字

currentColor 会取当前元素继承父级元素的文本颜色值或声明的文本颜色值，即 computed 后的 color 值。

比如，对于如下 CSS，该元素的边框颜色会是 red：

```
.btn {    color: red;    border: 1px solid currentColor;}
```

#### RGB[A] 颜色

RGB[A] 颜色是由 R(red)-G(green)-B(blue)-A(alpha) 组成的色彩空间。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRibDnxEYsdBqS0DtYcR4cwLo5rEicRjTSU20C08qIUYZyABS1wuSWA8Ow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在 CSS 中，它有两种表示形式：

- 十六进制符号；
- 函数符；

**十六进制符号**

RGB 中的每种颜色的值范围是 00~ff，值越大表示颜色越深。所以一个颜色正常是 6 个十六进制字符加上 # 组成，比如红色就是 #ff0000。

如果 RGB 颜色需要加上不透明度，那就需要加上 alpha 通道的值，它的范围也是 00~ff，比如一个带不透明度为 67% 的红色可以这样写 #ff0000aa。

使用十六进制符号表示颜色的时候，都是用 2 个十六进制表示一个颜色，如果这 2 个字符相同，还可以缩减成只写 1 个，比如，红色 #f00；带 67% 不透明度的红色 #f00a。

**函数符**

当 RGB 用函数表示的时候，每个值的范围是 0~255 或者 0%~100%，所以红色是 rgb(255, 0, 0)， 或者 rgb(100%, 0, 0)。

如果需要使用函数来表示带不透明度的颜色值，值的范围是 0~1 及其之间的小数或者 0%~100%，比如带 67% 不透明度的红色是 rgba(255, 0, 0, 0.67) 或者 rgba(100%, 0%, 0%, 67%)

> 需要注意的是 RGB 这 3 个颜色值需要保持一致的写法，要嘛用数字要嘛用百分比，而不透明度的值的可以不用和 RGB 保持一致写法。比如 rgb(100%, 0, 0) 这个写法是无效的；而 rgb(100%, 0%, 0%, 0.67) 是有效的。

在第 4 代 CSS 颜色标准中，新增了一种新的函数写法，即可以把 RGB 中值的分隔逗号改成空格，而把 RGB 和 alpha 中的逗号改成 /，比如带 67% 不透明度的红色可以这样写 rgba(255 0 0 / 0.67)。另外还把 rgba 的写法合并到 rgb 函数中了，即 rgb 可以直接写带不透明度的颜色。

#### HSL[A] 颜色

HSL[A] 颜色是由色相(hue)-饱和度(saturation)-亮度(lightness)-不透明度组成的颜色体系。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRe3FMj2NeOib2oY4PbwHSR3tQQ25CV83FgQXEHBmBj4TcosT0HHnSlrw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 色相（H）是色彩的基本属性，值范围是 0360 或者 0deg360deg， 0 (或 360) 为红色, 120 为绿色, 240 为蓝色；
- 饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0~100% 的数值；0% 为灰色， 100% 全色；
- 亮度（L），取 0~100%，0% 为暗，100% 为白；
- 不透明度（A），取 0100%，或者01及之间的小数；

写法上可以参考 RGB 的写法，只是参数的值不一样。

给一个按钮设置不透明度为 67% 的红色的 color 的写法，以下全部写法效果一致：

```
button {    color: #ff0000aa;    color: #f00a;    color: rgba(255, 0, 0, 0.67);    color: rgb(100% 0% 0% / 67%);    color: hsla(0, 100%, 50%, 67%);    color: hsl(0deg 100% 50% / 67%);}
```

小提示：在 Chrome DevTools 中可以按住 shift + 鼠标左键可以切换颜色的表示方式。

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

### 媒体查询

媒体查询是指针对不同的设备、特定的设备特征或者参数进行定制化的修改网站的样式。

你可以通过给 `<link>` 加上 media 属性来指定该样式文件只能对什么设备生效，不指定的话默认是 all，即对所有设备都生效：

```
<link rel="stylesheet" src="styles.css" media="screen" /><link rel="stylesheet" src="styles.css" media="print" />
```

都支持哪些设备类型？

- all：适用于所有设备；
- print：适用于在打印预览模式下在屏幕上查看的分页材料和文档；
- screen：主要用于屏幕；
- speech：主要用于语音合成器。

> 需要注意的是：通过 media 指定的 资源尽管不匹配它的设备类型，但是浏览器依然会加载它。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRF33VJ5F9PLR7NJhTj10CLT1oGdPsewqoUY155nCcpezTibXNCqU4YhA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

除了通过 `<link>` 让指定设备生效外，还可以通过 `@media` 让 CSS 规则在特定的条件下才能生效。响应式页面就是使用了 @media 才让一个页面能够同时适配 PC、Pad 和手机端。

```
@media (min-width: 1000px) {}
```

媒体查询支持逻辑操作符：

- and：查询条件都满足的时候才生效；
- not：查询条件取反；
- only：整个查询匹配的时候才生效，常用语兼容旧浏览器，使用时候必须指定媒体类型；
- 逗号或者 or：查询条件满足一项即可匹配；

媒体查询还支持**众多的媒体特性**[10]，使得它可以写出很复杂的查询条件：

```
/* 用户设备的最小高度为680px或为纵向模式的屏幕设备 */@media (min-height: 680px), screen and (orientation: portrait) {}
```

### 常见需求

#### 自定义属性

之前我们通常是在预处理器里才可以使用变量，而现在 CSS 里也支持了变量的用法。通过自定义属性就可以在想要使用的地方引用它。

自定义属性也和普通属性一样具有级联性，申明在 :root 下的时候，在全文档范围内可用，而如果是在某个元素下申明自定义属性，则只能在它及它的子元素下才可以使用。

自定义属性必须通过 `--x` 的格式申明，比如：--theme-color: red; 使用自定义属性的时候，需要用 var 函数。比如：

```
<!-- 定义自定义属性 -->:root {    --theme-color: red;}<!-- 使用变量 -->h1 {    color: var(--theme-color);}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRHt2Rs073BS2JVYQG3wicfBib7wDL9xNJONzfnbGoPnzQeIQwSmFkPwHQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

上图这个是使用 CSS 自定义属性配合 JS 实现的动态调整元素的 box-shadow，具体可以看这个 **codepen demo**[11]。

#### 1px 边框解决方案

Retina 显示屏比普通的屏幕有着更高的分辨率，所以在移动端的 1px 边框就会看起来比较粗，为了美观通常需要把这个线条细化处理。

而这里附上最后一种通过伪类和 transform 实现的相对完美的解决方案：

只设置单条底部边框：

```
.scale-1px-bottom {    position: relative;    border:none;}.scale-1px-bottom::after {    content: '';    position: absolute;    left: 0;    bottom: 0;    background: #000;    width: 100%;    height: 1px;    -webkit-transform: scaleY(0.5);    transform: scaleY(0.5);    -webkit-transform-origin: 0 0;    transform-origin: 0 0;}
```

同时设置 4 条边框：

```
.scale-1px {    position: relative;    margin-bottom: 20px;    border:none;}.scale-1px::after {    content: '';    position: absolute;    top: 0;    left: 0;    border: 1px solid #000;    -webkit-box-sizing: border-box;    box-sizing: border-box;    width: 200%;    height: 200%;    -webkit-transform: scale(0.5);    transform: scale(0.5);    -webkit-transform-origin: left top;    transform-origin: left top;}
```

#### 清除浮动

什么是浮动：浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素。

为什么要清楚浮动，它造成了什么问题？

因为浮动元素会脱离正常的文档流，并不会占据文档流的位置，所以如果一个父元素下面都是浮动元素，那么这个父元素就无法被浮动元素所撑开，这样一来父元素就丢失了高度，这就是所谓的浮动造成的父元素高度坍塌问题。

父元素高度一旦坍塌将对后面的元素布局造成影响，为了解决这个问题，所以需要清除浮动，让父元素恢复高度，那该如何做呢？

这里介绍两种方法：通过 BFC 来清除、通过 clear 来清除。

#### **BFC 清除浮动**

前面介绍 BFC 的时候提到过，计算 BFC 高度的时候浮动子元素的高度也将计算在内，利用这条规则就可以清除浮动。

假设一个父元素 parent 内部只有 2 个子元素 child，且它们都是左浮动的，这个时候 parent 如果没有设置高度的话，因为浮动造成了高度坍塌，所以 parent 的高度会是 0，此时只要给 parent 创造一个 BFC，那它的高度就能恢复了。

而产生 BFC 的方式很多，我们可以给父元素设置overflow: auto 来简单的实现 BFC 清除浮动，但是为了兼容 IE 最好用 overflow: hidden。

```
.parent {    overflow: hidden;}
```

通过 overflow: hidden 来清除浮动并不完美，当元素有阴影或存在下拉菜单的时候会被截断，所以该方法使用比较局限。

#### 通过 clear 清除浮动

我先把结论贴出来：

```
.clearfix {    zoom: 1;}.clearfix::after {    content: "";    display: block;    clear: both;}
```

这种写法的核心原理就是通过 ::after 伪元素为在父元素的最后一个子元素后面生成一个内容为空的块级元素，然后通过 clear 将这个伪元素移动到所有它之前的浮动元素的后面，画个图来理解一下。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRy6yLCjLXExZwEAdd61FxaHJIOsqF89ELUsFv6oGHiaPv4ViazkpAVdibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可以结合这个 **codepen demo**[12] 一起理解上图的 clear 清楚浮动原理。

上面这个 demo 或者图里为了展示需要所以给伪元素的内容设置为了 ::after，实际使用的时候需要设置为空字符串，让它的高度为 0，从而父元素的高度都是由实际的子元素撑开。

该方式基本上是现在人人都在用的清除浮动的方案，非常通用。

### **消除浏览器默认样式**

针对同一个类型的 HTML 标签，不同的浏览器往往有不同的表现，所以在网站制作的时候，开发者通常都是需要将这些浏览器的默认样式清除，让网页在不同的浏览器上能够保持一致。

针对清除浏览器默认样式这件事，在很早之前 CSS 大师 Eric A. Meyer 就干过。它就是写一堆通用的样式用来重置浏览器默认样式，这些样式通常会放到一个命名为 reset.css 文件中。比如大师的 **reset.css**[13] 是这么写的：

```
html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary,time, mark, audio, video {    margin: 0;    padding: 0;    border: 0;    font-size: 100%;    font: inherit;    vertical-align: baseline;}/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section {    display: block;}body {    line-height: 1;}ol, ul {    list-style: none;}blockquote, q {    quotes: none;}blockquote:before, blockquote:after,q:before, q:after {    content: '';    content: none;}table {    border-collapse: collapse;    border-spacing: 0;}
```

他的这份 reset.css 据说是被使用最广泛的重设样式的方案了。

除了 reset.css 外，后来又出现了 **Normalize.css**[14] 。关于 Normalize.css, 其作者 necolas 专门写了一篇文章介绍了它，并谈到了它和 reset.css 的区别。这个是他写那篇文章的翻译版：**让我们谈一谈 Normalize.css**[15]。

文章介绍到：Normalize.css 只是一个很小的CSS文件，但它在默认的 HTML 元素样式上提供了跨浏览器的高度一致性。相比于传统的 CSS reset，Normalize.css 是一种现代的、为 HTML5 准备的优质替代方案，现在已经有很多知名的框架和网站在使用它了。

Normalize.css 的具体样式可以看这里 **Normalize.css**[16]

区别于 reset.css，Normalize.css 有如下特点：

- reset.css 几乎为所有标签都设置了默认样式，而 Normalize.css 则是有选择性的保护了部分有价值的默认值；
- 修复了很多浏览器的 bug，而这是 reset.css 没做到的；
- 不会让你的调试工具变的杂乱，相反 reset.css 由于设置了很多默认值，所以在浏览器调试工具中往往会看到一大堆的继承样式，显得很杂乱；
- Normalize.css 是模块化的，所以可以选择性的去掉永远不会用到的部分，比如表单的一般化；
- Normalize.css 有详细的说明文档；

### **长文本处理**

**默认：字符太长溢出了容器**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRDYn3d0xCeic8yOQIv7hSRCquFDA7sm1cS3r4o2nM0N3S7DIjutLibQ1Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**字符超出部分换行**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlR9ME0HrnUaEGhtgLoIV0icSEtAiboIQQSt7KprrbYRAtHRH0D3jNu9O1w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**字符超出位置使用连字符**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRBcSmz8TB3ECHKia7Lyz8g3V8z4nFdTibYXnsAeTyjlHzo71bRYmaOW1A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**单行文本超出省略**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRdoq5iaJpuGMeM2FUYDPpc9xya8ibqYOaictibQ7icRUxrs1YSmyX7JVozeQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**多行文本超出省略**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRD3dXqU8bPVrjNw6YbS2UobV91ALY00Q1RgTuiaUc4D2evIBRAl467Lg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

查看以上这些方案的示例： **codepen demo**[17]

有意思的是刚好前两天看到 chokcoco 针对文本溢出也写了一篇文章，主要突出的是对整块的文本溢出处理。啥叫整块文本？比如，下面这种技术标签就是属于整块文本：

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRRFd8D7SKWXR5I0VHUKHRXjVjk9r69AAvzzAm0Qtk2nT44cDv43B2qw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

另外他还对 iOS/Safari 做了兼容处理，感兴趣的可以去阅读下：**CSS 整块文本溢出省略特性探究**[18]。

### 水平垂直居中

让元素在父元素中呈现出水平垂直居中的形态，无非就 2 种情况：

- 单行的文本、inline 或者 inline-block 元素；
- 固定宽高的块级盒子；
- 不固定宽高的块级盒子；

以下列到的所有水平垂直居中方案这里写了个 **codepen demo**[19]，配合示例阅读效果更佳。

#### 单行的文本、inline 或 inline-block 元素

**水平居中**

此类元素需要水平居中，则父级元素必须是块级元素(`block level`)，且父级元素上需要这样设置样式：

```
.parent {    text-align: center;}
```

**垂直居中**

方法一：通过设置上下内间距一致达到垂直居中的效果：

```
.single-line {    padding-top: 10px;    padding-bottom: 10px;}
```

方法二：通过设置 `height` 和 `line-height` 一致达到垂直居中：

```
.single-line {    height: 100px;    line-height: 100px;}
```

#### 固定宽高的块级盒子

**方法一：absolute + 负 margin**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRMl5dU5t5WClx6OkXLL0H9DAgAZMPIz5foerhJrKNqj9aX4UIme8OHw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法二：absolute + margin auto**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRptRsO305cpoXmJ17u3LSAiawwCq1j3XnsE53wlDJwnDUlUzK9NRxBYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法三：absolute + calc**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRTkic3tiaN0nRJSmDzomj5buAe7qp5T5HeVQ1qWKskjBV0zCJIFXczOFQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### 不固定宽高的块级盒子

这里列了 6 种方法，其中的两种 line-height 和 writing-mode 方案看后让我惊呼：还有这种操作？学到了学到了。

**方法一：absolute + transform**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRUFr2cn76XzYtmP4N4y1mibXcianCGmUhRKCTCCvmoYNpE1orJPXdcrhQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法二：line-height + vertical-align**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRUMen8Xib1gf0YzKuZDhcYk9Oicnr8FrXDbKFPrDSEZANiaZdOp81uibkMw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法三：writing-mode**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRA0E03XJZy5iaT6SahoYrTaRMHBMqSfThWeVrFDxMm7V0Db6STWiciczfw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法四：table-cell**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRk6ER8ic1htzSj6n3B59dUZDQ0l24j4D5MxG388HPo8iaDsjXg4GZ2KDQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法五：flex**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRD8QF70ibzz9xrGID4Y7waPVhlLZdr9UALibO4FeFEETOibHeXeDmSCWXQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法六：grid**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRxX1Bj7icv1xx8YCmz7cfY9ic5TPTyuGXxwlCk0EK0qa6D76rEDiaZM9dg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 常用布局

#### 两栏布局（边栏定宽主栏自适应）

针对以下这些方案写了几个示例： **codepen demo**[20]

**方法一：float + overflow（BFC 原理）**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRWXImxROrcZalWd4x8PMPic4FUOMEV3gNrf2pmMwM7sB2qkibKDPnIdRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法二：float + margin**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRTegeumg78NFdtAV0qZGI9wopfia9ZeOtqnv9gU8glv3cRpZLOa6WpWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法三：flex**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlR54rnuVuicUYJahibtSLpXmcv2rO4Ejr5zNfOg0ynj5f1pNx3ia4hAbibSA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法四：grid**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRfVWgOTFiaib26ibcLV1hUS7601ibibCkh6UTq3ogPtT8BvTcBbWXe3UW03A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### 三栏布局（两侧栏定宽主栏自适应）

针对以下这些方案写了几个示例： **codepen demo**[21]

**方法一：圣杯布局**

注：aside是left和right的公共属性。

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRnb0NQpwz6la9MBqbv0usROYskUI6qIZ8JialRAyyX63WCsy8ibmTPqow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法二：双飞翼布局**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlReFYhP9Gv7Xv7ibV7bHWDB2WOOL2a49DgmzXiaopxkcpeA4iae57Tqyj4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法三：float + overflow（BFC 原理）**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRoZLQfrkecmDO906vUMWic5t99vXTB8xeMZd2F8aOLseLuNcJfGNkrJA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法四：flex**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRC83tJFnk9dOv7U4r7dcZJIpPR87xzKfraCJSBbmc4UFdFVYUvciaOfg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法五：grid**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRhDya1bV2OCloQ2lv3iaCAp4QCicwHuuqe8zckqQiauL5xv3f89u2ffk0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### 多列等高布局

结合示例阅读更佳：**codepen demo**[22]

**方法一：padding + 负margin**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRtJTzDrP7hXvRdrDUNRsYg81L6uLyrAAG5WzBnyybtSibdGw1ok82oDg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法二：设置父级背景图片**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRIBSibLn1enia79GU3BUws0RicgCdgOk9LGxeyDIUkyWew6s3ubfIF3bIQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### 三行布局（头尾定高主栏自适应）

列了 4 种方法，都是基于如下的 HTML 和 CSS 的，结合示例阅读效果更佳：**codepen demo**[23]

```html
<div class="layout">
    <header></header>
    <main>
        <div class="inner"></div>
    </main>
    <footer></footer>
</div>

html,body,.layout {
	height: 100%;
}
body {
	margin: 0;
}
header, footer {
	height: 50px;
}
main {
	overflow-y: auto;
}
```

**方法一：calc**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRFeKiaDrypwaz869Via2YNJcQSf5fbKxmeAU3HKF6f6nJJvGMbmjy5ORg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法二：absolute**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRFGrWNkN0ICrs1OQ4xJ9xAvUU1MXkcGPCMY2YtNe5VFVXoO7RVSld6Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法三：flex**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRoPnrAUnZVohzdrC1BMvbTbXA8xZznoobdO4eseeCsv2fzKnMe3bWGQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**方法四：grid**

![图片](https://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib2owcKuRPGMy93fs1vehWlRFKeCwuic0Q7RhGQO3t3Hia5ialdBaF14w6enVm11CTCEAOafjnIx58Yow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



## **JS**

### **防抖节流**

​	函数防抖和函数节流：优化高频率执行js代码的一种手段，js中的一些事件如页面的滚动（scroll，防抖），浏览器的resize（节流），鼠标的mousemove、mouseover，input输入框的keypress（节流）等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能。为了优化体验，需要对这类事件进行调用次数的限制。

1. 防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。
2. 节流：每隔一段时间，只执行一次函数。

```js
// 防抖
const debounce = function(fn, delay) {
 	// 借助闭包
    let timeout = null;
    return function() {
        let _this = this;
        let args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(function() {
            fn.apply(_this, args);
        }, delay);
    }
}

// 节流
const throttle = function(fn, delay) {
    let timeout = null;
    return funciton() {
    	let _this = this;
        let args = arguments;
        if(timeout) return;   // 目前有计时器在队列中，直接返回
        timeout = setTimeout(function() {
            fn.apply(_this, args);
            timeout = null;     // fn执行完毕后，将计时器清空
        }, delay);
        
    }
}
```

### **JS精度问题**

​	    JS 中 Number 统一采用双精度（64位）浮点数（同 java 中的 double 类型）表示（IEEE 745标准）。计算机中另一种保存数据的方法：定点数（约定前 n 位表示整数，后 m 位表示小数）。相较于定点数，浮点数的表示范围更大，但计算效率低有误差。浮点数计算公式：V = (-1)^S × M × 2^E。S 为符号位（1表示负数，0表示正数）；1  ≤ M < 2 表示尾数位（共52位），IEEE 745标准规定位数第一位隐含为1，不写；E 为指数位（共11位）。

​		**JS 安全数**：JS 的最大的安全整数。由上可知，尾数共 52 位，包括一位隐藏位，共 53 位。而最大的安全整数必然是尾数全部为 1 的浮点数，即为 1.11...11（小数部位一共52个1），该浮点数转换成二进制后为 111...111（共53个1），换算为10进制为 2^53-1，故双精度浮点数可以表示的最大安全整数就是 2^53-1。

​	十进制数与浮点数转换：http://www.binaryconvert.com/result_double.html

![双精度浮点数](G:\工作\面经准备\双精度浮点数.png)

​	**面试题：**为什么 JS 中 0.1 + 0.2 不等于 0.3，应该如何解决？

​		**原因：**

1.  0.1 转换成二进制码是有误差的，尾数是一个不断循环的数，但是浮点数的尾数是有限的，所以需要省略一部分，这就产生了一部分误差；
2.  在浮点数加法运算中，有对阶操作。如果尾数后面都是0（整数或者0.5之类的），没影响。但是 0.1 转换成的二进制浮点数码的尾数，对阶的时候舍弃部分尾数会造成误差。

​		**解决方法：**

1. 全部转换成整数，计算完再转化成小数；

   ```javascript
   function add(num1, num2) {
       const num1Digits = (num1.toString().split('.')[1] || '').length;
       const num2Digits = (num2.toString().split('.')[1] || '').length;
       const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
       return (num1 * baseNum + num2 * baseNum) / baseNum;
   }
   ```

2. 使用现有的库 mathjs 之类的。

### **继承**

六种继承方式：

1. 原型继承  实现： 将子类型的构造函数的原型指向，父类型的实例对象。
           // 两个缺点：
           // 1. 父类型的原型属性和方法会变成，子类型的实例对象的共享属性和方法，任何其中一个子类型的实例上发生改变，会全部改变。
           // 2. 子类型在实例化过程中，不能传参给父类型的构造函数。
2. 盗用构造函数继承
           缺点：1.必须在构造函数中定义方法，因此函数不能重用。（也是使用构造函数模式自定义类型的问题）
           2.子类不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。
3. 组合继承
           // 集中了原型链和盗用构造函数两者的优点
           // 缺点：父类构造函数始终会被调用两次 
           // 一次是创建子类原型时调用，第二次是在子类构造函数中调用
4. 原型式继承
           // 非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。
           // object() 中创建了一个中间函数，并让该函数的原型指向父类型构造函数的实例对象，最后返回一个该函数的实例对象。
           // object() 本质上是对传入的对象执行了一次浅复制。
           // ECMAScript5 通过增加Object.create()方法将原型式继承的概念规范化了。
5. 寄生式继承
           // 寄生式继承同样适合于：主要关注对象，而不在乎类型和构造函数的场景
           // 思路类似于寄生构造函数和工厂模式：
           // 创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象
           // 其实就是在原型式继承中对子类型的对象进行了属性或方法的扩展。
6. 寄生式组合继承
           // 相比组合继承，它最后把子类型构造函数的原型的 constructor 指回了自己
           // 寄生式组合继承可以算是引用类型继承的最佳模式

```javascript
        // 1.原型链继承
        // 实现： 将子类型的构造函数的原型指向，父类型的实例对象。
        // 两个缺点：
        // 1. 父类型的原型属性和方法会变成，子类型的实例对象的共享属性和方法，任何其中一个子类型的实例上发生改变，会全部改变。
        // 2. 子类型在实例化过程中，不能传参给父类型的构造函数。
        function SuperType() {
            this.superProperty = true;
        }
        SuperType.prototype.getSuperValue = function () {
            return this.superProperty;
        }
        function SubType() {
            this.subProperty = false;
        }
        // 将 SubType 的原型（prototype）指向 SuperType 创建的实例，实现继承
        SubType.prototype = new SuperType();
        SubType.prototype.getVal = () => {
            console.log(2);
        };
        SubType.prototype.getSubValue = function () {
            return this.subProperty;
        }
        let subInstance = new SubType();
        console.log(SubType.prototype);         // SuperType {superProperty: true, getVal: ƒ, getSubValue: ƒ}
        console.log(SubType.__proto__);         // ƒ () { [native code] }
        console.log(SubType.superProperty);     // undefined
        console.log(subInstance);               // SubType {subProperty: false}
        // 此处子类的实例就可以通过原型链调用父类的方法
        console.log(subInstance.getSuperValue());    // true
        console.log(subInstance.getVal());          // 2 undefined
        console.log(subInstance.getSubValue());     // false
        console.log(subInstance.__proto__.superProperty);   // true
        console.log(subInstance.constructor);       // f SuperType() { this.superProperty = true; }
        // 原型链继承的问题：子类的原型的 constructor 属性会指向父类而不是自己
        console.log(SubType.prototype.constructor);     // f SuperType() { this.superProperty = true; }
        console.log(subInstance instanceof Object);     // true
        console.log(Object.prototype.isPrototypeOf(subInstance));    // true

        // 圣杯模式：解决上面原型链继承的问题
        function inherit() {
            var F = function () { };
            return function (Target, Origin) {
                F.prototype = Origin.prototype;
                Target.prototype = new F();
                Target.constructor = Target;
                Target.prototype.uber = Origin.prototype;
            }
        }

        console.log("-------222222222222222222222222--------");

        // 2.盗用构造函数继承
        // 缺点：1.必须在构造函数中定义方法，因此函数不能重用。（也是使用构造函数模式自定义类型的问题）
        // 2.子类不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式。
        function SuperType1() {
            this.colors = ['red', 'green', 'yellow'];
        }
        function SubType1() {
            // 继承 SuperType
            SuperType1.call(this);
        }
        let stealInstance1 = new SubType1();
        stealInstance1.colors.push('blue');
        let stealInstance2 = new SubType1();
        stealInstance2.colors.push('brown');
        console.log(stealInstance1.colors);   //["red", "green", "yellow", "blue"]
        console.log(stealInstance2.colors);   //["red", "green", "yellow", "brown"]

        console.log("-------3333333333333333333--------");

        // 3. 组合继承
        // 集中了原型链和盗用构造函数两者的优点
        // 缺点：父类构造函数始终会被调用两次 
        // 一次是创建子类原型时调用，第二次是在子类构造函数中调用
        function SuperType2(name) {
            this.name = name;
            this.colors = ['pink', 'hotpink', 'skyblue'];
        }
        function SubType2(name, age) {
            // 继承属性
            SuperType2.call(this, name);
            this.age = age;
        }
        // 继承方法
        SubType2.prototype = new SuperType2();
        SubType.prototype.sayMsg = function () {
            console.log(this.name + this.age);
        }
        let mergeInstance1 = new SubType2('ldh', 22);
        let mergeInstance2 = new SubType2('zxy', 34);
        mergeInstance1.colors.push('white');
        console.log(mergeInstance1.colors);     // ["pink", "hotpink", "skyblue", "white"]
        console.log(mergeInstance1.name);       // ldh
        console.log(mergeInstance2.colors);     // ["pink", "hotpink", "skyblue"]
        console.log(mergeInstance2.name);       // zxy

        console.log("------44444444444444444-------");

        // 4. 原型式继承
        // 非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。
        // object() 中创建了一个中间函数，并让该函数的原型指向父类型构造函数的实例对象，最后返回一个该函数的实例对象。
        // object() 本质上是对传入的对象执行了一次浅复制。
        // ECMAScript5 通过增加Object.create()方法将原型式继承的概念规范化了。
        function object(obj) {
            function F() { };
            F.prototype = obj;
            return new F();
        }
        let person = {
            name: 'ldh',
            colors: ['gray', 'purple', 'black']
        }
        let son1 = object(person);
        son1.name = 'qing';
        son1.colors.push('red');
        let son2 = object(person);
        son2.name = 'zxy';
        son2.colors.push('pink');
        console.log(son1);      // F {name: "qing"}
        console.log(son2);      // F {name: "zxy"}

        console.log("--------555555555555555--------");

        //5. 寄生式继承
        // 寄生式继承同样适合于：主要关注对象，而不在乎类型和构造函数的场景
        // 思路类似于寄生构造函数和工厂模式：
        // 创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象
        // 其实就是在原型式继承中对子类型的对象进行了属性或方法的扩展。
        function createAnother(origin) {
            // 通过调用函数创建一个新对象
            // 以某种方式增强这个对象
            let newObj = object(origin);
            newObj.Song = function () {
                console.log("music!!!");
            }
            return newObj;
        }
        let person1 = {
            name: 'zxc',
            friends: ['ldh', 'zxy', 'gtl']
        }
        let son3 = createAnother(person1);
        let son4 = createAnother(person1);
        console.log(son3);      // F {Song: ƒ}
        //      Song: ƒ ()
        //      __proto__:
        //      friends: (3) ["ldh", "zxy", "gtl"]
        //      name: "zxc"
        //      __proto__: Object
        console.log(son4);      // 同上

        console.log("--------6666666666666666666666--------");

        // 6. 寄生式组合继承
        // 相比组合继承，它最后把子类型构造函数的原型的 constructor 指回了自己
        // 寄生式组合继承可以算是引用类型继承的最佳模式
        function SuperType3(name) {
            this.name = name;
            colors = ['red', 'yellow', 'pink'];
        }
        SuperType3.prototype.sayName = function () {
            console.log("myname is: " + this.name);
        }
        function SubType3(name, age) {
            SuperType.call(this, name);
            this.age = age;
        }
        SubType3.prototype = new SuperType3();
        SubType3.prototype.constructor = SubType3;
        SubType.prototype.sayAge = function () {
            console.log("my age is: " + this.age);
        }

```



### **闭包**

​	**特性：**

​		1.函数嵌套函数；2.函数内部可以引用外部的参数和变量；3.参数和变量不会被垃圾回收机制回收。

​	**实现原理：**作用域链

​	**闭包的定义及其优缺点**

​		==简单的描述闭包：==如果在函数func内部声明函数inner，然后在函数外部调用inner，这个过程即产生了一个闭包。闭包最大的用处有两个：可以读取到函数内部的变量，让这些变量的值始终保持在内存中

​		==闭包== 是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。==闭包的缺点==就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。闭包是javascript语言的一大特点，主要应用闭包场合主要是为了：设计私有的方法和变量。一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！

​		使用闭包时因为作用域链引来的副作用，（闭包只能得到包含函数中变量的最后一个值）如果直接用下面第一种（for循环中用var声明索引值）写***导致result中每个函数的参数都是arr[arr.length],在《JavaScript高级程序设计》书中提到的最典型的解决此问题的方法就是用一个立即执行的匿名函数代替闭包负值给数组，这个匿名函数有一个参数num，因为函数参数是按值传递的所以传递给num的就是当前for循环的值。

​	**javascript的垃圾回收原理**

1. 在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收；

2. 如果两个对象互相引用，而不再被第 3 者所引用，那么这两个互相引用的对象也会被回收。

​	**使用闭包的好处**

1. 希望一个变量长期驻扎在内存中；
2. 避免全局变量的污染；
3. 私有成员的存在。

​    **闭包使用场景**

​		1.防抖、节流      计时器是否为空对象，需要用闭包进行保存，计时器中的this指向为计时器对象，要先保存外部函数的this，不然的话在计时器中用箭头函数。

​			https://segmentfault.com/a/1190000023425946

1. 模仿块级作用域（ES6使用 let、const）

   ```javascript
   // 每隔 1S 打印依次打印
   // 应尽量避免往全局作用域中添加变量和函数。
   for(var i = 0; i < 5; i++) {
       (function(j) {
           setTimeout( () => console.log(j), j*1000 );   // 注意这里的 j*1000
       })(i)
   }
   ```

2. 私有变量。利用闭包创建用于访问私有变量的公有方法（也称为特权方法）。私有变量包括函数的参数、局部变量和函数内定义的其他函数。

   ```javascript
   // 变量a、b、sum，只能在 add 函数内部访问到，
   // 通过在函数内部创建闭包，闭包就可以通过自己的作用域链访问到它们
   function add(a, b) {
   	var sum = a + b;
       return sum;
   }
   // 两种在对象上创建特权的方法
   // 1.在构造函数中定义特权方法
   function MyObject() {
       // 私有变量和私有函数
       var privateVar = 10;
       function privateMethod() {
           return false;
       }
       // 特权方法  （new 创建的对象只能访问到 publicMethod 方法）
   	this.publicMethod = function() {
           privateVal++;
           return privateMethod;
       }
   }
   // 2.利用私有和特权成员，可以隐藏那些不应该被直接修改的数据
   function Foo(name) {
       // 特权方法 getName() （闭包） 可以在构造函数外使用，通过它可以访问内部的私有变量 name。
       this.getName = funciton() {
           return name;
       }
   }
   ```

3. 静态私有变量。创建特权方法也可以通过在私有作用域中定义地有变量或函数来实现。

4. 模块模式。模块模式是为单例创建私有变量和特权方法。

   ```javascript
   var singleton = {
       name: value,
       method: function() {},
   }
   // 模块模式通过到哪里添加私有变量和特权方法能够使其增强
   var singleton = funciton() {
       // 模块模式使用了一个返回对象的匿名函数。
       // 在匿名函数内部，首先定义了私有变量和函数。
       var privateVar = 10;
       function privateMethod() {
           return false;
       }
       return {
           publicProperty: true,
           publicMethod: function() {
               privateVal++;
               return privateMethod;
           }
       }
   }
   // 增强模块模式
   var singleton1 = function() {
       var privateVal = 10;
       function privateMethod() {
           return false;
       }
       var obj = new Person();    // 首先创建一个对象，再对其增强（增加新的属性和方法）后返回
       obj.publicProperty = true;
       obj.publicMethod = function() {
           privateVal++;
           return privateMethod;
       }
       return obj;
   }
   ```

5. Vue 源码中的闭包

   ```javascript
   // 1.数据响应式 Observer 中使用闭包（省略闭包之外的相关逻辑）
   function defineProperty(obj, key, value) {
       return Object.defineProperty(obj, key, {
           get() {
               return value;
           },
           set(newValue) {
               value = newValue;
           }
       })
   }
   // 2.结果缓存
   // cached 函数（接受一个函数，返回一个函数）
   // 这个函数可以读取缓存，如果缓存中没有就存一下放到缓存中再读。
   // 闭包正是可以做到这一点，因为不会释放外部的引用，从而函数内部的值可以得到保留。
   function cached(fn) {
       var cache = Object.create(null);
       return (function cachedFn (str) {
           var hit = cache[str];
           return hit || (cache[str] = fn(str))
       })
   }
   ```

### **script async/defer**

​		https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html

1. 1 <script> HTML文件被解析，知道脚本文件被命中，此时解析将停止并请求获取文件（如果它是外部的），直到将在恢复解析之前执行该脚本；
2. 2 <script async> async 在 HTML 解析期间下载文件，并在文件下载后暂停 HTML 解析器以执行它；
3. 3 <script defer> defer 在 HTML 解析过程中下载文件，并且只有在解析器完成后才会执行它。defer 脚本也保证按照它们在文档中出现的顺序执行。（defer/async 的下载不会阻塞 DOM 的渲染）

​     **一般使用规则：**

1. 如果脚本是模块化的并且不依赖于任何脚本，则使用  async ；
2. 如果脚本依赖或被另一脚本依赖，则使用 defer ；
3. 如果脚本很小，并且是 async 脚本所依赖的，那么使用一个内联脚本，在script脚本上不添加任何属性 。 

<img src="G:\工作\面经准备\async_defer.png" alt="async_defer" style="zoom: 80%;" />

### V8**引擎的内存管理**

​		原文：https://deepu.tech/memory-management-in-v8/

​		中文转载：https://mp.weixin.qq.com/s/vvZy6rBb8RyTaiBKo5ryHg

​		Javascript 是一种解释性语言，它需要一个引擎来解释和执行代码。V8引擎解释 JavaScript 并将其编译成机器码。V8是用 C++ 编写的，可以嵌入任何 C++ 程序中。由于 JavaScript 是单线程语言，所以 V8 为每一个 JavaScript 开启一个新的进程。在 V8 进程中，一个正在运行的程序总是有一些分配的内存来表示，称为常驻集（Resident Set）。常驻集包括栈和堆。

​		每个 V8 进程有一个栈。这里存储静态数据，包括方法/函数框架、原始值（基本数据类型）和指向对象的指针。栈内存限制可以使用 --stack_size V8 标志设置。==堆内存==是 V8 存储对象和动态数据的地方。这是内存中区域最大的块，也是垃圾回收（GC）发生的地方。注意并不是整个堆内存的空间都会垃圾回收，只有新旧空间（ New space、 Old space ）是垃圾回收管理的。堆内存可进一步划分为新空间、老空间、大对象空间、代码空间、单元空间、属性单元空间、映射空间。

### **垃圾回收**

​	**内存泄漏**：由于疏忽或错误导致程序未能释放已经不再使用的内存。（全局变量、DOM事件、定时器、闭包等）

​	**1.标记清除**

​	当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

​	垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

​	**2.引用计数**

​	引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为 0 的值所占用的内存。

​	问题：**循环引用**。循环引用指的是对象 A 中包含一个指向对象B的指针，而对象 B 中也包含一个指向对象 A 的引用。

### **强引用/弱引用**

​		如果我们持有一个对象的引用，则这个对象不会被垃圾回收，这里的引用指的是强引用。一个对象只被弱引用所引用，则被认为是不可访问的（或弱可访问的），并因此可能在任何时刻被回收。

### **全局变量优缺点**

​	==全局变量的优点：==可以减少变量的个数，减少由于实际参数和形式参数的数据传递带来的时间消耗。
​	==全局变量的缺点：==

1. 全局变量保存在静态存贮区，程序开始运行时为其分配内存，程序结束释放该内存。与局部变量的动态分配、动态释放相比，生存期比较长，因此过多的全局变量会占用较多的内存单元。
2. 全局变量破坏了函数的封装性能。函数像一个黑匣子，一般是通过函数参数和返回值进行输入输出，函数内部实现相对独立。但函数中如果使用了全局变量，那么函数体内的语句就可以绕过函数参数和返回值进行存取，这种情况破坏了函数的独立性，使函数对全局变量产生依赖。同时，也降低了该函数的可移植性。
3. 全局变量使函数的代码可读性降低。由于多个函数都可能使用全局变量，函数执行时全局变量的值可能随时发生变化，对于程序的查错和调试都非常不利。

### **JS 标准内置对象**

​		js 中的内置对象主要指的是在程序执行前，存在于全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数。如全局变量 NaN、undefined 等，全局函数如 parseInt() 、parseFloat() ，构造函数如 Date、Object等，还有提供数学计算的内置对象如 Math 对象。

1. 值属性。返回一个简单值，没有自己的属性和方法。Infinity、NaN、undefined、globalThis；
2. 函数属性。可以直接调用，不需要在调用时指定调用对象。eval、isNaN、parseInt、parseFloat、encodeURI等；
3. 基本对象。是定义或使用其他对象的基础。Object、Function、Boolean、Symbol；
4. 错误对象。拥有基本的错误类型，同时也有多种具体的错误类型。Error、TypeError、ReferenceError、SyntaxError等；
5. 数字和日期对象。表示数字、日期和执行数学计算的对象。Number、BigInt、Date、Math；
6. 字符串。String、RegExp；
7. 可索引的集合对象。表示可按照索引值来排序的对象，包括数组、类数组。Array、Int8Array、Int16Array、Float32Array等；
8. 使用键的集合对象。这些对象在存储时会使用键。Map、WeakMap、Set、WeakSet；
9. 结构化对象。表示和操作结构化的缓冲区数据。JSON；
10. 控制抽象对象。帮助构造代码，尤其是异步代码。Promise、Generator、AsyncFunction；
11. 反射。Reflect、Proxy。

### **判断一个对象是否为空**

1. 根据 for ... in 遍历对象，如果存在则返回 true，否则返回 false：

   ```javascript
   for(let i in obj)
   	return false;    // 不为空，返回 false 
   return true;		// 为空，返回 true
   ```

2. JSON 的 stringify() 来判断，大概思路是转化成字符串 "{}" 来判断：

   ```javascript
   if(JSON.stringify(obj) === "{}") 
       return true;
   return false;
   ```

3. ES6 中的 Object.keys() 方法（推荐）。Object.keys(obj) 会遍历一个对象，并返回其可枚举属性组成的数组。

   ```javascript
   Object.keys(obj).length === 0 ? "空" : "不为空";
   ```

### **判断一个对象是数组**

1. ES5的一个api（最稳妥，未解决下面的2里面的4种判断方法的问题而创建的）：Array.isArray([]);      // true

2. ```javascript
   var arr = [1,2,3];
   arr instanceof Array;     // true
   arr.constructor === Array;   // true 
   Arrray.prototype.isPrototypeOf(arr);    // true
   Object.getPrototypeOf(arr) === Array.prototype;  // true
   
   // 问题来了 
   // 手动指定某个对象的__proto__属性为Array.prototype，导致该对象继承了Array对象，使得基于继承的判断方案全部失效。
   var a = { __proto__: Array.prototype, }
   a instanceof Array;   // true
   a.constructor === Array;  // true
   Array.prototype.isPrototypeOf(a);   // true
   Object.getPrototypeOf(a) === Array.prototype;   // true
   ```

3. 在浏览器兼容性问题下的更稳妥方法：Object.prototype.toString.call/apply( [] );       // "[object Array]"  。

   **注意：**1.Object.toString() 会报错，因为 Object 是一个构造函数，构造函数里没有 toString() 这个方法，而构造函数是不在原型链上的，只有他的实例才能够通过原型链找到这个方法。2.不能 obj.toString() ，object 的子类会重写 toString() 方法，其返回结果不是数据类型。

### **数组深拷贝**

```javascript
// 设原数组为 arr
// 下面其实都是浅拷贝
// 1.for循环
// 2.arr.concat()   或   [].concat(arr)
// 3.arr.slice(0)    slice方法会返回一个新数组
// 4.[...arr]    ES6新语法，扩展运算符
```

### **柯里化**

​		柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。

```javascript
function curry(fn, args) {
    var length = fn.length;
    args = args || [];
    return function() {
        var _args = args.slice(0),
            arg, i;
        for (i = 0; i < arguments.length; i++) {
            arg = arguments[i];
            _args.push(arg);
        }
        if (_args.length < length) {
            return curry.call(this, fn, _args);
        }
        else {
            return fn.apply(this, _args);
        }
    }
}

var fn = curry(function(a, b, c) {
    console.log([a, b, c]);
});

fn("a", "b", "c") // ["a", "b", "c"]
fn("a", "b")("c") // ["a", "b", "c"]
fn("a")("b")("c") // ["a", "b", "c"]
fn("a")("b", "c") // ["a", "b", "c"]
```
### **symbol**

​		**symbol** 是一种基本数据类型 （[primitive data type](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)）。`Symbol()`函数会返回**symbol**类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法："`new Symbol()`"。

​	每个从`Symbol()`返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型==仅有的目的==。

```javascript
// 	可以使用 symbol 在对象上创建私有属性，
const obj = {};
const sym = Symbol();
obj[sym] = "foo";
obj.bar = "bar";
console.log(obj); // { bar: 'bar' }
console.log(sym in obj); // true
console.log(obj[sym]); // foo
console.log(Object.keys(obj)); // ['bar']

// 但是，Reflect.ownKeys() 方法能够获取对象上所有键的列表，包括字符串和 symbol 
function tryToAddPrivate(o) {
    o[Symbol("Pseudo Private")] = 42;
}
const obj = { prop: "hello" };
tryToAddPrivate(obj);
console.log(Reflect.ownKeys(obj));
// [ 'prop', Symbol(Pseudo Private) ]
console.log(obj[Reflect.ownKeys(obj)[1]]); // 42
```

### **stringify/parse**

​	JSON.stringify() 九大特性 https://segmentfault.com/a/1190000021230185

```javascript
// 1.对于 undefined、任意的函数以及 symbol 三个特殊的值分别作为对象属性的值(1)、数组元素(2)、单独的值时(3), JSON.stringify() 将返回不同的结果。   
// (1)将跳过（忽略）对他们进行序列化；(2)转换为null；(3)返回undefined。

// 2.非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。
// 3.转换值中如果有 toJSON() 函数，这个函数返回什么值，序列化结果就是什么值，并且忽略其他属性的值。
// 4.会正常序列化 Date 的值。因为 Date 对象自己部署了 toJSON() 方法，所以 Date 对象会被当做字符串处理。
// 5.NaN 和 Infinity 格式的数值及 null 都会被当作 null。
// 6.对于基本类型的序列化，Boolean、number、string 的包装对象在序列化时会自动转换成对应的原始值。

// 7.关于对象属性的是否可枚举，其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。
// 8.在深拷贝中最直接的方法是 JSON.parse(JSON.stringify(obj))，但是因为 stringify 的这些特性会带来很多坑，如循环引用问题。    ---》对包含循环引用的对象执行此方法，会抛出错误。
// 9.对于 symbol 属性的一个补充，所有以 symbol 为属性键的属性都会被完全忽略掉，即使 replacer 参数中强制指定包含了它们。
```

​	**JSON.stringify() 的第二个参数 replacer 和 第三个参数 space**

​		**replacer**：1.作为函数时，它有两个参数（key、value），对每个属性值都会执行一次该函数。需要注意的是，replacer 被传入的函数时，第一个参数不是对象的第一个键值对，而是空字符串作为 key 值，value 值是整个对象的键值对。    2.如果 replacer 是一个数组，指向属性在这个数组里面，这个键值对才会被序列化。

​		**space**：1.是个数字时，每两个被序列化的元素之间缩进这么多个空格（最多10个空格）；2.是个字符串时，则缩进该字符串（长度大于10时缩进该字符串的前10个字符）。

### **reduce() 实现**

```javascript
// reduce() 方法接收一个函数作为累加器，最后返回一个值。
function _reduce (fn, initialVal) {
    if(typeof fn === 'undefined') {
        throw('第一个参数必须是函数');
    }
    var arr = this;
    if(!Array.isArray(arr)) {
        throw('必须是数组调用此方法')；
    }
    var base = typeof initialVal == 'undefined' ? 0 : initialVal;
    var startIndex = typeof initialVal == 'undefined' ? 1 : 0;
    arr.slice(startIndex).forEach((ele, index) => {
        base = fn(base, ele, index + startIndex, arr);
    });
    return base;
}
var arr = [1,2,3,4];
const add = (pre, cur) => pre + cur;
console.log(_reduce.call(arr, add, 0));    // 10
```

### **null / undefined**

​	null 表示一个“无”的对象，转换成数值时为 0；undefined 是一个表示“无”的原始值，转换为数值时为 NaN。

​	**undefined的用法：**

1. 用 var 声明一个变量但未赋值时，该变量为 undefined；
2. 调用函数时，应该提供的参数没有提供，该参数等于 undefined；
3. 函数没有返回值时，默认返回 undefined；
4. 对象没有赋值的属性，该属性的值为 undefined。

​	**null 的用法:**

1. 作为函数的参数，表示一个该函数的参数不是一个对象；
2. 作为对象原型链的终点。

### **typeof  /  instanceof**

1. typeof：用于判断参数的是什么类型的实例，返回值为说明运算数类型的字符串。返回值结果包括："number"、"string"、"boolean"、"object"、"function"、"undefined"、"symbol"。若参数为引用类型，始终返回"object"。

2. instanceof ：用来检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。

   ```javascript
   // instanceof 的底层实现原理，手动实现一个 instanceof
   function _instanceof (L, R) {  // L：左表达式，R：右表达式
       var O = R.prototype;
       L = L.__proto__;
       while (true) {
           if (L === null) return false;
           if (O === L) return true;  // 都需要为严格等于
           L = L.__proto__;
       }
   }
   ```

### **call/apply/bind**

​		bind不加后面的括号返回的是函数，加上后面的括号返回的是函数值，这也是bind和call，apply的主要区别，bind需要二次调用，而call和apply返回的是函数值，是直接调用。bind() 有柯里化性质，而且 bind() 可以作为构造函数，即可以使用 new 进行初始化（但此时 this 值会失效）。

```javascript
// call 模拟实现
Function.prototype.call2 = function (context) {    // 传入第一个参数为要绑定的对象。
    var context = context || window;    // this 参数为 null 时，视为指向 window。
    context.fn = this;  // 通过this 获取调用 call2的函数，普通方法中的this，谁调用就指向谁。
    var args = [];   // 获取其余参数
    for (var i = 1, len = arguments.length; i < len; i++) {
        // args.push(arguments[i]);
        args.push("arguments[" + i + "]");
    }
    // context.fn(...args);
    // eval() 会将字符串转换成语句进行执行
    var res = eval("context.fn(" + args + ")");
    delete context.fn;
    return res;
}
// apply 模拟实现
// apply() 接收两个参数（不会像 call() 那样参数数量不可知），第二个参数为数组（也可能没有传入）
Function.prototype.apply1 = function (context, arr) {
    var context = context || window;
    context.fn = this;
    var result;
    if (!arr) {    // 第二个参数没有传参时
        result = context.fn();
    } else {
        var args = [];
        for (let i = 0, len = arr.length; i < len; i++) {
            args.push("arr[" + i + "]");
        }
        result = eval("context.fn(" + args + ")");
    }
    delete context.fn;
    return result;
}
// bind() 模拟实现
Function.prototype.newBind = function (context) {
    if (typeof this !== "function") {
        throw new Error("不是一个函数");
    }
    var that = this;   // 获取调用本函数的对象（函数）
    // arguments是一个类数组，本质上还是一个对象，调用数组的原型方法需要用 call() 进行绑定
    var args1 = Array.prototype.slice.call(arguments, 1); // 获取所有参数
    var o = function () { };    // 原型式继承，借用一个空函数实现
    var newF = function () {
        var args2 = Array.prototype.slice.call(arguments);
        var args = args1.concat(args2);
        // 判断是否使用 new 来初始化对象
        // 是的话把方法绑定到新的实例对象上。
        if (this instanceof o) {
            that.apply(this, args);
        } else {
            that.apply(context, args);
        }
    }
    o.prototype = that.prototype;
    newF.prototype = new o();
    return newF;
}
```

## 场景题

### **后端一次给前端 10 万条数据，如何优雅地展示。**

https://juejin.cn/post/6986237263164211207

```javascript
function loadAll(response) {
	    var html = "";
	    for (var i = 0; i < 100000; i++) {
	        html += "<li>title:" + '我正在测试'+[i] + "</li>";
	    }
        $("#content").html(html);
}
// 		刷新页面数据十分卡，性能瓶颈是在将 html 字符串插入到文档中这个过程上，
// 也就是 $("content").html(html) 这局代码的执行。
```

​		一次性渲染 10 万条数据会造成页面加载速度缓慢，可分批次处理，但是在单线程的同一代码流程中运行，并不能解决问题，反而会使代码复杂化。这种问题在其他语言中可用多线程来处理。JS 中可根据单线程的特点，用异步处理机制。setTimeout 和 setInterval 两个函数能起到和多线程差不多的效果。三个方法，一个数据分组，将每一组存入数组中并返回该数组；一个方法加载某一批次的数据；最后一个方法在计时器中进行调用。

### **一个按钮，怎么优化**

从用户体验和安全的角度回答。

​		1.按钮的样式优化，点击之后颜色变灰，防止重复点击，点击之后有遮罩层，loading等待画面。

​		2.防止脚本注入的攻击，防范措施。

### **项目做浏览器的兼容性处理**

### **前端并发冲突**

问题场景：不同用户在较短时间内变更数据，或者某一个用户进行的重复提交操作，都可能导致并发冲突。

1. 一般的处理方式：每次发请求添加 loading。每次用户操作页面上的控件（输入框、按钮等），向后端发送请求时，都给页面对应的控件添加 loading 效果，提示正在进行数据加载，同时也阻止 loading 效果结束前用户继续操作控件。

2. axios 拦截器统一处理。由于是在每次发送请求时进行并发控制，那么重新封装下发送请求的公共函数，统一处理重复请求实现自动拦截。主要思路：利用axios interceptors API 拦截请求，检测是否有多个相同的请求同时处于 pedding 状态，如果有就调用 cancel token API 取消重复的请求。用到 axios 库拦截请求的两个核心 api。

   - interceptors。拦截器包括请求拦截器和响应拦截器，可以在请求发送前或者响应后进行拦截请求。

     ```javascript
     let penddingRequests = new Map();   // 将所有 pendding 状态的请求存储在一个变量中
     // 把每个请求的方法、url和参数组合成一个字符串，作为标识该请求的唯一 key。
     const requestKey = `${config.url}/${JSON.stringify(config.params)}/${JSON.stringify(config.data)}&request_type=${config.method}`;
     
     
     // 添加请求拦截器
     axios.interceptors.request.use(function(config) {
         // 在发送请求之前做些什么
         if(penddingRequests.has(requestKey)) {
             config.cancelToken = new axios.CancelToken((cancel) => {
                 // cancel 函数的参数会作为 promise 的 error 被捕获
                 cancel(`重复请求被主动拦截： ${requestKey}`);
             })
         }else {
             penddingRequests.set(resquestKey, config);
             config.keyRequestKey = requestKey;
         }
         return config;
     }, function(error) {
         // 对请求错误做些什么
         // 这里出现错误可能是网络波动造成的，清空 peddingRequests 对象
         penddingRequests.clear();
         return Promise.reject(error);
     });
     
     // 添加响应拦截器
     // 如果请求做到了相应拦截器这一步，说明这个请求已经结束了 pendding 状态，要把它从 penddingRequests 中除名。
     axios.interceptors.response.use(function(response) {
         // 对响应数据做些什么
         const requestKey = response.config.requestKey;
         peddingRequests.delete(requestKey);
         return Promise.resolve(response);
     }, function(error) {
         // 对响应错误做些什么
         if(axios.isCancel(error)) {
             console.warn(error);
             return Promise.reject(error);
         }
         penddingRequests.clear();
         return Promise.reject(error);
     })
     ```

   - cancel token。调用cancel token API 可以取消请求。官网提供了两种方式来构建 cancel token ，这里采用这种方式： 通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token ，方便在上面的请求拦截器中检测到重复请求时可以立即执行。

     ```javascript
     const CancelToken = axios.CancelToken;
     let cancel;
     axios.get('/user/12345', {
     	cancelToken: new CancelToken(function executor(c) {
     		// executor 函数接收一个 cancel 函数作为参数
             cancel = c;
     	})
     });
     // 取消请求
     cancel();
     ```

### 	**HTML页面渲染的基本过程**

1. 解析HTML文件，创建DOM树

   2．解析CSS,形成CSS对象模型

   3．将CSS与DOM合并，构建渲染树（renderingtree）

   4．布局和绘制

## **前端/浏览器**

### 	  **从输入 url 到页面加载完成发生了什么（==重要==）**

​       主要包括三部分，即客户端的处理，网络的连接建立，服务器的处理。DNS解析-->TCP连接-->发送HTTP请求-->服务器处理请求并返回HTTP报文-->浏览器解析渲染页面-->连接结束。

​        输入url后，首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。之后需要找到这个url域名的服务器ip,为了寻找这个ip，浏览器首先会寻找缓存，查看缓存中是否有记录，缓存的查找记录为：浏览器缓存-》系统缓存-》路由器缓存，缓存中没有则查找系统的hosts文件中是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器。

​        服务器解析这个请求来作出响应，返回相应的html给浏览器，因为html是一个树形结构，浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面，之后根据外部样式，内部样式，内联样式构建一个CSS对象模型树CSSDOM树，构建完成后和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点。

​        之后进行布局，布局主要是确定各个元素的位置和尺寸，之后是渲染页面，因为html文件中会含有图片，视频，音频等资源，在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，当然在这些所有的请求中我们还需要关注的就是缓存，缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control，在请求这些有设置了缓存的数据时，会先 查看是否过期，如果没有过期则直接使用本地缓存，过期则请求并在服务器校验文件是否修改，如果上一次 响应设置了ETag值会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验 Last-Modified，没有设置ETag则直接验证Last-Modified，再决定是否返回304。

### **浏览器多进程 / 多线程**

​	https://segmentfault.com/a/1190000012925872

#### 		**多进程**

​             **浏览器是多进程的（每一个标签页）**，每打开一个标签页，就创建了一个独立的浏览器进程。它们之间控制页面渲染，脚本执行和时间处理，互不影响。主要的进程如下：

1. Browser进程（控制进程）。浏览器的主进程（负责协调、主控），只有一个。作用有：（1）.负责浏览器页面显示，与用户交互，如前进后退等；（2）.负责各个页面的管理，创建和销毁其他进程；（3）.将渲染进程得到的内存中的bitMap，绘制到用户界面上；（4）.网络资源的管理，下载等。
2. 第三方插件进程，每种类型的插件对应一个进程，仅当使用该插件时才创建；
3. GPU进程，最多一个，用于 3D 绘制；
4. 渲染进程（浏览器内核，也叫 renderer 进程，内部是多线程的），默认每个标签页面一个进程，互不影响。主要作用为页面渲染、脚本执行和事件处理等。

####        **多线程**

​             **浏览器的渲染进程是多线程的**。主要常驻线程有：

1. **GUI渲染线程**。（1）负责渲染浏览器界面，解析HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等；（2）当界面需要重绘或由于某种操作引发回流时，该线程就会执行；（3）==GUI 渲染与 JS 引擎线程是互斥的==，当 JS 引擎执行的时候 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS  引擎空闲时立即被执行。
2. **JS引擎线程**。（1）负责 JavaScript 程序的解析和运行（如 V8 引擎）；（2）js 引擎会一直等待任务队列中任务的到来，然后进行处理，一个 Tab 页（renderer进程）中无论什么时候都只有一个 JS 线程在运行 JS 代码；（3）同样需要注意的是，js 引擎线程和 GUI 渲染进程是互斥的，如果 JS 执行的时间过长，会造成页面的渲染卡顿，导致页面渲染加载阻塞；
3. **事件触发线程**。（1）归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解为 JS 引擎自己都忙不过来，需要浏览器另开线程来协助）；（2）当 JS 引擎执行代码块如 setTimeout 时（也可以来自浏览器内核中的其他线程，如鼠标点击，AJAX 异步请求等），会将对应任务添加到事件线程中；（3）当对应的时间符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理；（4）要注意的是，由于 JS 单线程的关系，所有在等待处理队列中的时间都需要排队等待 JS 引擎的处理。
4. **定时触发器线程**。（1）是 setTimeout 和 setInterval 所在的线程；（2）浏览器定时计数器并不是由 JS 引擎计数的（因为 JS 引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确性）；（3）所以会通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）；（4）需要注意的是，W3C 在 HTML 标准中规定，要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。
5. **异步 http 请求线程**。（1）一个 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求；（2）当检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由 Javascript 引擎执行。

####     **Browser 进程和渲染进程的通信过程**

​        打开一个浏览器时，必定会开两个进程（Browser进程和渲染进程）。页面加载流程如下：

- Browser 进程收到用户请求，首先需要获取页面内容（如从服务器获得的相应内容），然后将该任务通过 RendererHost 接口传递给渲染进程；
- 渲染进行的 renderer 接口收到消息并进行简单解析后，交给渲染线程，然后开始渲染。
  1. 渲染进程收到请求，加载网页并渲染网页，这个过程中可能需要 Browser 进程获取资源和需要 GPU 进程来协助渲染；
  2. JS 线程操作 DOM （可能会造成回流并重绘）；
  3. 最后渲染进程将结果传递给 Browser 进程。
- Browser 进程接收结果并将结果绘制出来。

### **页面渲染优化**

1. HTML文档结构层次尽量少，最好不深于六层；
2. 脚本尽量后放，放在前即可；
3. 少量首屏样式内联放在标签内；
4. 样式结构层次尽量简单；
5. 在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流；
6. 减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；
7. 动画尽量使用在绝对定位或固定定位的元素上；
8. 隐藏在屏幕外，或在页面滚动时，尽量停止动画；
9. 尽量缓存DOM查找，查找器尽量简洁；
10. 涉及多域名的网站，可以开启域名预解析。

### 	**浏览器缓存（重要）**

<img src="https://upload-images.jianshu.io/upload_images/4845448-39248bf4a3b45c3e?imageMogr2/auto-orient/strip|imageView2/2/w/800/format/webp" alt="img" style="zoom:67%;" />

​		http缓存指的是: 当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。

​		常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应则无能为力，

**缓存的优点：**

- 减少了冗余的数据传输，节省网费；
- 减少了服务器的压力，提升性能；
- 加快了客户端加载网页的速度。

由响应头中的 Cache-Control 来控制浏览器的缓存机制。缓存规则在服务器中或 nginx 中配置。

Cache-Control中的几个取值含义：`private`：仅浏览器可以缓存；`public`：浏览器与代理服务器（中间代理、cdn等）可以缓存；`max-age = xxx`：过期时间；     `s-maxage` ：仅替换 CDN 缓存的 max-age 指令；告知 CDN 可以缓存内容的秒数。当达到设置的时间时，CDN 必须与源服务器重新验证内容。`no-chache`：不进行强缓存；`no-store`：两种缓存都不进行。

注：max-age:0 与 no-cache 在效果上一致，但 max-age:0 会先进行强缓存的判断。

**强缓存**：请求一个数据时，首先看cache-control，看 max-age 上的时间是否已经过期，没过期直接取缓存数据，过期了则走协商缓存。如果没有cache-control，会取expires的值，来对比是否过期；

**协商缓存**：两个属性值。ETag：每个文件都有一个，文件一改变，该属性的值就会改变；Last-Modified：服务器声明的文件最后的修改时间。每次 http 返回来 Response Header 中的 ETag 和 Last-Modified。之后每次请求会带上这两个属性的值（注意名称改变了：ETag -> If-None-Match，Last-Modified -> If-modified-Since），服务器会与当前的资源进行对比，如果判断资源没有改变，则返回 304 状态码，不返回资源，浏览器加载本地缓存数据来加载页面。如果改变，返回新资源（200）和新规则，浏览器接收资源并更新规则（ETag、Last-Modified）。

**启发式缓存：**如果响应中未显示Expires，cache-control: max-age 或 cache-control: s-maxage，并且响应中不包含其他有关缓存的限制，缓存可以根据启发式方法计算新鲜度寿命。通常会用响应头的两个字段，Date  -  (Last-modified) 值的 10%作为缓存时间。 

F5 会跳过强缓存，走协商缓存； Ctrl + F5 会跳过所有缓存。

### 浏览器渲染原理与过程

浏览器渲染的过程主要包括以下五步：

1. 浏览器将获取的HTML文档解析成DOM树。
2. 处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。
3. 将DOM和CSSOM合并为渲染树(`rendering tree`)，代表一系列将被渲染的对象。
4. 渲染树的每个元素包含的内容都是计算过的，它被称之为布局`layout`。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。
5. 将渲染树的各个节点绘制到屏幕上，这一步被称为绘制`painting`。

### 	**cookie、storage（重要）**

常常会问cookie、localStorage 和 sessionStorage 的区别，或 cookie 和 session 的区别

Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。

cookie、localStorage 和 sessionStorage 共同点：都是保存在浏览器端，并且是同源的

两者粗略的区别：1.存储大小（Cookie 4K，Storage 5M）；2.有效期（Cookie拥有有效期，Storage在浏览器关闭时失效或永久存储；3.Cookie会发送到服务器端，存储在内存中，Storage只存储在浏览器端；4.路径（Cookie有路径限制，Storage只存储在域名下）；5.API（Cookie没有特定的API，Storage有对应的API））

- Cookie：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）
- sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；存储在sessionStorage、localStorage中的数据都不受页面刷新的影响；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个会话过程，关闭浏览器后消失，session为一个会话，当页面不同即使是同一页面打开两次，也被视为同一次会话）
- localStorage：localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）

**<u>cookie是什么</u>**

HTTP 协议中的 Cookie 包括 `Web Cookie` 和`浏览器 Cookie`，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态。

> HTTP Cookie 机制是 HTTP 协议无状态的一种补充和改良

有两种类型的 Cookies，一种是 Session Cookies，一种是 Persistent Cookies，如果 Cookie 不包含到期日期，则将其视为会话 Cookie。会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。如果 Cookie 包含`有效期` ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。



**<u>补充说明一下cookie的作用：</u>**

- 保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。
- 跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便
- 定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。

**为什么封装Storage**

- Storage本身有API，但是只是简单的key/value形式；
- Storage只存储字符串，需要人工转换成json对象；
- Storage只能一次性清空，不能单个清空。

**<u>Session 是什么</u>**

客户端请求服务端，服务端会为这次请求开辟一块`内存空间`，这个对象便是 Session 对象，存储结构为 `ConcurrentHashMap`。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。

1. session 跟踪：通过在 cookie 中附加一个 session ID 的方式来实现session 跟踪。

2. cookie 被禁用怎么办：利用 URL 重写把 session ID直接附加在 URL 路径的最后面。

3. session 的缺点：Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。

### 	**web 安全（重要）**

​	1.XSS 跨站脚本攻击（Cross Site Scripting)

如何攻击：受害者浏览器执行恶意代码。恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。

如何防止：（1）、把用户的输入解读成数据而不是代码；（2）、用户的输入及请求都进行过滤检查，如对特殊字符进行过滤，设置熟人如玉的匹配规则等。

​	2.[跨站请求伪造（CSRF）](https://juejin.im/post/59e6b21bf265da43247f861d) （Cross-site request forgery）

如何攻击：攻击者盗用了用户的身份，并以该用户的名义发送恶意请求，冒充用户在站内的正常操作。

如何防止：（1）通过 token 或者验证码来检测用户提交；（2）尽量不要在页面的链接中暴露用户隐私信息；（3）对于用户修改删除等操作最好都使用 post 操作；（4）避免全站通用的 cookie，严格设置 cookie 的域。（5）验证 HTTP Referer 字段，利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer记录了该 HTTP 请求的来源地址。

### **跨域**

​	跨域，指的是浏览器不能执行其他网站的脚本。==它是由浏览器的同源策略造成的，是浏览器对Javascript施加的安全限制==。同源：协议、域名、端口号三者皆相同。防止浏览器端恶意的抓取和篡改数据。

​	**1.浏览器为什么有同源策略**

​		为了限制其他源文档或脚本与当前源的资源进行交互。主要有两个地方：一个是 iframe 节点访问控制，如果没有同源策略限制的话， iframe 可以随意访问其他非同源 iframe 的 dom 节点。如钓鱼网站嵌套了一个银行网站的 iframe，从外部可以读取到内部密码输入框的值。另一个是 ==http 响应控制==，如果没有同源策略的话，在第三方网站直接对其他网站发起请求，可以读取到响应，这样就可以获取用户的个人信息，造成隐私泄露。

​	**2.上面说到的响应控制，请求是成功的吗？**

​		利用 img/frame 等支持跨域的标签，请求会自动带上 cookie ，没有额外处理的话请求是成功的，这也就是 csrf 攻击。而如果是 ajax，不会带上 cookie，需要鉴权的请求也就直接失败。注意同源策略只是对终端进行信息防护，只拦截响应，不拦截请求。

​	**3.浏览器不直接拦截非同源请求？**

​		浏览器需要通过响应才知道要不要拦截，如果直接拦截请求了，想用 CORS 做跨域请求就做不了了。

**解决跨域问题**

​	**（1） 使用CORS（跨资源共享）解决跨域问题**

​			CORS跨域：服务端设置，前端直接调用（说明：后台允许前端某个站点进行访问）

​			CORS是一个W3C标准，全称是“跨域资源共享”（Cross-origin resource sharing）。它允许浏览器想跨域服务器，发出XMLHttpRequest请求，从而克服了Ajax只能同源使用的限制。CORS需要浏览器和服务器同时支持。目前搜有浏览器都支持该功能（IE10+）。整个CORS通信过程， 都是浏览器自动完成， 不需要用户参与。对于开发者而言，CORS通信与同源的Ajax通信没有差别，代码完全一样。浏览器一旦发现Ajax请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信（在 header 中设置： "Access-Control-Allow-Origin", "*" ；Access-Control-Allow-Credentials:true（响应头中，表示允许带上cookie））。

```xml
// spring中在spring-mvc.xml中加入如下代码
<mvc:cors>
    <mvc:mapping path="/**"           // 对任何的请求资源都可以进行请求（/*：对这一层，/**：所有）
                 allowed-origins="*"  // 允许任何的源
                 allowed-methods="POST, GET, OPTIONS, DELETE, PUT, PATCH"   // 允许的请求方式
                 allowed-headers="Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With"      
                 allow-credentials="true" />
</mvc:cors>
```

​	**（2） 使用JSONP解决跨域问题**

​		JSONP跨域：前端适配，后台配合（说明：前后端同时改造。需要先安装jsonp插件npm install jsonp --save-dev，不是请求，而是一段js脚本）			

​		JSONP（JSON with Padding）是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。有同源策略，一般来说位于 server1.example.com 的网站无法与 server2.example.com 的服务器沟通，而 HTML 的 <script> 元素是一个例外。利用 <script> 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的额 JSONP。用 JSONP 抓到的资料并不是  JSON，而是任意的 Javascript，用 Javascript直译器执行而不是用 JSON 解析器解析（需要目标服务器配合一个 callback 函数）。

```javascript
jsonp(url, {option}, (error, res) => {
	this.data = res;
})
```

​	注：CORS 与 JSONP 的比较：两者使用目的相同，但是 CORS 功能更强大。JSONP 只支持 GET 请求， CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。

​	**（3） 使用 Nginx 反向代理解决跨域问题**

​		接口代理：通过修改nginx服务器配置来实现（说明：前端修改，后端不动）			

CORS 和 JSONP 都需要服务器支持，当服务器无法设置 header 或提供 callback 时我们就可以采用 Nginx 反向代理的方式解决跨域问题。Nginx 配置跨域案例，在 nginx.conf 的 location 中增加如下配置：

```nginx
add_header Access-Control-Allow-Origin *或域名;
add_header Access-Control-Allow-Methods X-Requested-With;
add_header Access-Control-Allow-Methods GET,POST,OPTIONS;
```

### 	**性能优化（重要）**

1.加载资源优化（静态资源的压缩合并、静态资源缓存）

2.渲染优化（css 放头部，js 放最后；懒加载；减少 dom 查询，对查询结果缓存；减少 dom 操作，多个操作合并一起执行；事件节流）

二、（1）减少 http 请求（CSS sprites精灵图；字体图标；合并脚本和样式表）；（2）减少CDN；（3）减少重绘和重排；（4）缓存机制；（5）css、js 文件压缩

### **浏览器和 Node 事件循环的区别？**

其中一个主要的区别在于浏览器的event loop 和nodejs的event loop 在==处理异步事件的顺序==是不同的。

nodejs中有micro event;其中Promise属于micro event 该异步事件的处理顺序就和浏览器不同.nodejs V11.0以上 这两者之间的顺序就相同了。

宏任务：script、setTimeout、setInterval、setImmediate、I/O、UI rendering、postMessage、MessageChannel；

微任务：Promise.then()或catch()、Promise为基础开发的其他技术（如fetch API、v8的垃圾回收过程）、Node独有的process.nextTick、MutationObserve、Object.observe(已废弃，Proxy对象替代)。

首先明确， `.then` 或者 `.catch` 的参数期望是函数，传入非函数则会发生值透传（ `value => value` ）

`event loop` 执行顺序：

- 首先执行 `script` 宏任务
- 执行同步任务，遇见微任务进入微任务队列，遇见宏任务进入宏任务队列
- 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完
- 执行浏览器 UI 线程的渲染工作
- 检查是否有`Web Worker`任务，有则执行
- 执行下一个宏任务，回到第二步，依此循环，直到宏任务和微任务队列都为空

### **URI/URL**

​	URL 是 URI 的子集。

1. URI（uniform resource identifier）: 统一资源标识符。用字符串标识某一互联网资源。
2. URL（uniform resource locator）:  统一资源定位符。表示资源的地点。

### 	**两种路由方式 （hash 路由和 history 路由、会手写实现）**

## **vue**

官方文档：https://vuejs.org

​	vue 是渐进式的js框架，vue的核心库只关注视图层，结合了HTML+CSS+JS，非常易用，并且有很好的生态系统。而且Vue的体积很小，速度很快，优化很到位。

​	cdn：内容分发网络，一种加速策略，可从最近的服务器上快速地获得外部的资源。

vue优点：

1. 轻量级、体积小。Vue.js压缩后只有20kb+（Angular压缩后56kb+，React压缩后44kb+）。

2. 移动优先，更适合移动端，如移动端的Touch事件。

3. 易上手，学习曲线平稳，文档齐全。

4. 吸取了Angular（模块化）和React（虚拟DOM）的长处，并拥有自己独特的功能，如计算属性。

5. 开源，社区活跃度高。

   插值表达式 {{ }} 可获取vue对象中的属性值来自于 data、computed、props

**计算属性：computed**

​		计算属性的重点突出在属性两个字上（**属性是名词**），首先它是个属性，其次这个属性有计算的能力（计算式动词），这里的计算就是个函数；简单点说，他就是一个能将计算结果缓存起来的属性（将行为转化成了静态的属性），仅此而已。

​		注：computed里虽然存放的是函数，但在调用时，computed里的东西是一个属性。使用时，与方法的不同在于，conputed里的属性不用加()，methods里面的需要加()。一些常用的函数，可以缓存起来，在调用时直接使用缓存中的结果，一次来提高效率。

**监控属性：watch**

​		通过watch里给属性绑定函数，当属性的值发生变化时，该函数就会自动被调用。调用时可以接收两个参数，第一个参数是属性改变后的值，第二个参数是属性改变前的值。

​		**vue核心**：虚拟DOM和diff算法

​	vue高效的核心，就是虚拟DOM和diff算法，vue不通过修改DOM树来达到修改的效果，而是直接在页面上修改目标元素，此时这个元素就是一个虚拟的DOM。通过diff算法，计算出虚拟DOM修改前与修改后的区别，然后在虚拟DOM的原基础上进行修改，这样效率就会大大提升。

### **响应式原理**

​	https://juejin.cn/post/6844903597986037768

​		1.vue 将 data 初始化为一个 Observer， 并对对象中的每个值重写了 get、set方法，data 中的每个 key 都有一个独立的依赖收集器；

​		2.在 get 中，向依赖收集器添加了监听；

​		3.在 mount 时，实例了一个 Watcher，将收集器的目标指向了当前 Watcher；

​		4.在 data 值发生改变时，触发 set，触发了所有依赖收集器中的所有监听的更新，来触发 Watcher.update。

```javascript
//  Vue2.x 的响应式实现模拟
// 模拟 Vue 中的 data 选项 
    let data = { 
      msg: 'hello' 
    } 
    // 模拟 Vue 的实例 
    let vm = {} 
    // 数据劫持：当访问或者设置 vm 中的成员的时候，做一些干预操作 
    Object.defineProperty(vm, 'msg', { 
      // 可枚举（可遍历） 
      enumerable: true, 
      // 可配置（可以使用 delete 删除，可以通过 defineProperty 重新定义） 
      configurable: true, 
      // 当获取值的时候执行 
      get () { 
        console.log('get: ', data.msg) 
        return data.msg 
      }, 
      // 当设置值的时候执行 
      set (newValue) { 
        console.log('set: ', newValue) 
        if (newValue === data.msg) { 
          return 
        } 
        data.msg = newValue 
        // 数据更改，更新 DOM 的值 
        document.querySelector('#app').textContent = data.msg 
      } 
    }) 
    // 测试 
    vm.msg = 'Hello World' 
    console.log(vm.msg) 
```

​	https://zhuanlan.zhihu.com/p/347968769

#### 	**Vue2 的响应式流程**

1. 在 init 数据初始化的时候，对象内不通过 defineReactive 方法，使用 Object.defineProperty 将属性进行==劫持==（这个时候只会劫持已经存在的属性）。如果数据是数据类型，Vue2 中是通过重写数组方法来实现的，多层对象的话是通过递归来实现劫持的；
2. 在初始化流程中的编译阶段，当 render function 被渲染的时候，会读取到 Vue 实例中和视图相关的响应式数据，此时会触发 getter 函数进行 ==依赖收集== （将观察者 Watcher 对象存放到当前闭包的订阅者 Dep 的 subs 中），此时的数据劫持功能和观察者模式就实现了 MVVM 模式中的 Binder，之后就是正常的渲染和更新流程；
3. 当数据发生变化或视图导致的数据发生变化时，会触发数据劫持的 setter 函数，setter会通知初始化依赖收集中的 Dep 中和视图相应的 Watcher，告知需要重新渲染视图，Watcher 就会再次通过 update 方法来更新视图。

####    Vue3 在响应式原理上的优化

​		简单而言：Proxy 是直接代理对象，而不是劫持对象的属性；更好的数组监控。

​		vue3重写响应式的核心点在于 defineProperty 不能很好的实现对数组下标的监控，而在 Vue2 的实现代码中，没有更好的方案对此进行改善。（尤雨溪原话：性能代价和获得的用户收益不成正比）。Vue3 中全新的 Composition Api 实现了响应式系统。使用 Proxy 实现的响应式代码，要比使用 defineProperty 的代码简单得多，因为 Proxy 天然的能够对整个对象做监听，而不需要对数据行遍历后做监听。

### **Vue 双向数据绑定原理**

​	答：vue.js 是采用数据劫持 结合 发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
具体步骤：
​	第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化
​	第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
​	第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
1、在自身实例化时往属性订阅器(dep)里面添加自己
2、自身必须有一个update()方法
3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。
第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

### **vue2.0与3.0的区别**

1. 项目目录结构。vue-cli3.0移除了配置目录，config和build文件夹，同时移除了static静态文件夹，新增了public文件夹，index.html移动到了public中；
2. 配置项。3.0中 config 文件被移除，但是多了 .env.production 和 env.deveopment 文件，实际配置没有改变。没了 config 文件，跨域需要配置域名时，从 config/index.js 移到了 vue.config.js 中，配置方法不变；
3. 渲染。2.0 使用 Virtual Dom 实现的渲染。3.0 不论是原生的 HTML 标签还是 vue 组件，都会通过 h 函数来判断，如果是原生 HTML 标签，在运行时直接通过 Virtual Dom 来直接渲染，如果是组件直接生成组件代码；
4. 数据监听。2.x使用的 es5 的 object.defineProperties 中 getter 和 setter 来实现。3.0中是基于 proxy来监听，按需监听。（速度加倍，内存减半）；
5. 按需引入。2.x中 new 出的实例对象，所有东西都在这个 vue 对象上，无论用没用到都会跑一遍。 3.0 中可以用 ES module import 按需引入，如 keep-alive内置组件，v-model 指令等等。

### **虚拟DOM**

​		Virtual DOM 只是js模拟的DOM结构，是HTML DOM的抽象 。虚拟DOM是由js实现的避免DOM树频繁更新，通过js的对象模拟DOM中的节点，然后通过特定的render方法将它渲染成真实的节点，数据更新时，渲染得到新的 Virtual DOM，与上一次得到的 Virtual DOM 进行 diff，得到所有需要在 DOM 上进行的变更，然后在 patch 过程中应用到 DOM 上实现UI的同步更新。

​		虚拟DOM是将状态映射成视图的解决方案之一（另一种是Angular的脏检查）。他的运行原理是==使用状态生成虚拟节点==，然后使用虚拟节点渲染视图。

​		==先使用状态生成虚拟节点的原因==：直接使用状态生成真实DOM，会有一定程度的性能浪费。而 先创建虚拟节点，再渲染视图。可以先将虚拟节点缓存，然后用新生成的虚拟节点与上一次缓存的旧虚拟节点比对。根据结果就可以只更新需要更新的真实DOM节点，从而避免不必要的DOM操作，节省性能开销。

​		**虚拟DOM 与真实 DOM 的区别**

​			1、虚拟DOM不会进行排版与重绘操作

​			2、虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要改的部分（注意！），最后并在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘损耗

​			3、真实DOM频繁排版与重绘的效率是相当低的

​			4、虚拟DOM有效降低大面积（真实DOM节点）的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部

​		**虚拟DOM在Vue.js中主要做了两件事**

1. 提供与真实DOM节点所对应的虚拟节点vnode；
2. 将提供的虚拟节点vnode与旧虚拟节点oldVnode进行比对，再更新视图。

### **Diff** 

​	==Diff作用==

​	Diff 的出现，就会为了减少更新量，找到最小差异部分DOM，只更新差异部分DOM就好了。这样消耗就会小一些，数据变化一下，没必要把其他没有涉及的没有变化的DOM 也替换了。

​	==Diff 做法==

​	Vue 只会对新旧节点中 父节点是相同节点 的 那一层子节点 进行比较。也可以说成是只有两个新旧节点是相同节点的时候，才会去比较他们各自的子节点。最大的根节点一开始可以直接比较，这也叫做 同层级比较，并不需要递归，虽然好像降低了一些复用性，也是为了避免过度优化，是一种很高效的 Diff 算法。

​	`diff` 算法是一种通过同层的树节点进行比较的高效算法

​	**两个特点**：

- 比较只会在同层级进行, 不会跨层级比较
- 在diff比较的过程中，循环从两边向中间比较

### **vue生命周期**

答： Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。
它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。

#### **Vue生命周期总共有几个阶段**

​	它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。
​		**创建前/后**： 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。
​		**载入前/后**：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。
​		**更新前/后**：当data变化时，会触发beforeUpdate和updated方法。
​		**销毁前/后**：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。

### **第一次页面加载会触发哪几个钩子**

答：第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子

### **组件间通信**

​	https://github.com/febobo/web-interview/issues/12

​	分类：父子组件、兄弟组件、祖孙与后代组件、非关系组件之间。

​	`vue`中8种常规的通信方案

1. 通过 props 传递。父组件传递数据给子组件。子组件设置 props 属性，定义接收父组件传递过来的参数，父组件在使用子组件标签中通过字面量来传值。

2. 通过 $emit 触发自定义事件。子组件传值给父组件。子组件通过 $emit 触发自定义事件，$emit第二个参数是传递的数值。

3. 使用 ref。父组件在使用子组件时设置 ref，再通过设置子组件 ref 来获取数据。

   ```javascript
   <Children ref="foo">
   this.$refs.foo   // 获取子组件实例
   ```

   

4. EventBus。兄弟组件传值。创建一个中央时间总线 EventBus。兄弟组件通过 $emit 触发自定义事件，$emit第二个参数为传递的值。另一个兄弟组件通过 $on 监听自定义事件。

5. $parent 或$root。通过共同祖辈 $parent 或 $root 搭建通信侨联。

   ```javascript
   this.$parent.on("add", this.add);
   // 另一个兄弟组件emit
   this.$parent.emit("add")
   ```

   

6. attrs 与 listeners。祖先传递数据给子孙。

7. Provide 与 Inject。在祖先组件中定义 provide 属性，返回传递的值。在后代组件通过 inject 接收组件传递过来的值。

8. Vuex。状态管理机，相当于一个用来存储共享变量的容器。

### **Vuex**

​	Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式（状态机）。状态管理：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可预测。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证以一种可预测的方式发生变化。Vuex也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。**主要作用：**在兄弟组件或者是没有任何关系的组件之间，进行数据的存储和共享。

​	Vuex 和单纯的全局对象有以下两点不同：

1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
2. 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地**提交 (commit) mutation**。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

### **路由**

vue中的路由，可在一个vue组件中实现其他组件的相互切换。通过路由模块，可将指定的组件显示在路由视图中。路由跳转

#### 路由设置(webpack-simple)

以 webpack-simple 为例

（1）安装路由模块

​	npm install vue-router -s

（2）设计路由界面

（3）创建路由表

```vue
import Home from './views/Home'
import Products from './views/Products'

export const routes = [
	{
		path: '/Home',
		components: Home
	},
	{
		path: '/Products',
		components: Products
	}
]
```

（4）在 main.js 中使用路由模块及注册路由表

```vue
import Vue from 'vue'
import App from './App.vue'
import VueRouter from 'vue-router'  // 1.引入路由模块
import {routes} form './routes'     // 2.引入静态路由表（没有 ./ 的话会被认为是一个插件）

Vue.use(VueRouter)   // 3.使用路由模块

// 4.创建一个 VueRouter 模块的实例
const router = new VueRouter({
	routes: routes
});

new Vue({
	el: "#app",
	router,   // 5.把 router 实例放入到 vue 实例中
	render: h => h(App)
}) 
```

（5）创建路由链接和路由视图

```vue
// 在 App.vue 中

<template>
	<div id="app">
        <div>
            <span><router-link to="/Home">首页</router-link></span>
            <span><router-link to="/Products">商品列表</router-link></span>
    	</div>
        <router-view></router-view>
    </div>
</template>
```

#### 路由设置(webpack)

（1）创建路由配置表。在 src 路径下创建 router 文件夹，里面创建 index.js，此时该文件就是一个路由表。

```javascript
import Vue from 'vue'
import Router from 'vue-router'
import Login from '../views/Login'

// 安装路由
Vue.use(Router);
// 配置路由
export default new Router({
	routes: [
        {
            // 路由路径
            path: '/Login',
            // 路由名称   name是加载组件时引用的值
            name: 'Login',
            // 跳转到组件
            component: Login
        }
    ]
});
```

（2）在 main.js 中配置路由表

```javascript
import Vue from 'vue'
import App from './App'
import VueRouter from 'vue-router'  // 全局使用路由模块
// 导入上面创建的路由配置表，会自动去router路径下找 index.js
import router from './router'   
Vue.use(VueRouter);
Vue.config.productionTip = false
new Vue({
    el: "#app",
    // 配置路由
    router,
    components: { App },
    template: '<App/>'
});
```

（3）在 App.vue 中创建路由视图

```html
<template>
    <div id="app">
        <router-view></router-view>
    </div>
</template>
```

向 router 实例中添 加 mode 属性：

- 值"hash"：url 带 #，适用于调试模式；
- 值"history"：url 不带 #

#### 路由之间的参数传递

==设参==：通过路由表，设置路由参数

```javascript
{
    path: '/Products/:id',
    component: Products
}
```

==传参==：通过 router-link 的 to 访问路径时携带参数（这里是1）

```vue
<li role="presentation"><router-link to="/Products/1">手机</router-link></li>
```

​	在传参中，有多个参数需要传递时，有以下两种方法：

1. router-link（将to改成了:to，为了将这一属性当成对象使用，注意router-link中name属性名称一定要和路由中的name属性名称匹配，才能找到对应的路由路径。params属性中放置需要传递的各个参数）

   ```html
   <rotuer-link :to="{name:'UserProfile', params: {id:1}}">个人信息</rotuer-link>
   ```

2. 代码方式

   ```javascript
   this.$router.push({name:'UserProfile', params: {id:1}});
   ```

==接参==：通过 vue 中的 $route.params.id     （注：id 要与设参里的  id 相对应）

#### 嵌套路由（子路由）

​	在路由显示的组件内部，又嵌套着路由，称为子路由。

​	嵌套路由的实现：

1. 配置路由表（在要嵌套的路由表中添加属性children）

   ```javascript
   {    path:'/Home',    name:'Home',    component:Home,    children: [        {            path:'/productlist',     // 此处的地址前面没有/Home            name:'Productlist',            component:Productlist        }    ]}
   ```

   2.使用嵌套路由（router-view标签中显示子路由里的模板，待跳转的地方添加router-link，或button＋@click点击事件实现跳转）

   ```html
   <el-menu-item>    <router-link to="/Productslist">商品列表</router-link></el-menu-item><router-view></router-view>
   ```

#### 路由的一些细节

​	（1）路由之间的跳转

​		（一）通过 HTML 中的路由 <router-link to="路由地址">链接进行跳转

​		（二）通过 js 实现路由的跳转。按钮绑定函数，在函数中使用 this.$router.push("路由地址")

​	（2）组件的重定向（直接调用另一个已配置好的路由对象即可）

```javascript
routes:[    {        path: '/Login',        name: 'Login',        component: Login    },    {        path: '/Gologin',        redirect: '/Login'    }]
```



### **创建 Webpack 项目**

（1）下载和使用 webpack 骨架  （vue init webpack 项目名）

![](G:\工作\面经准备\webpack创建.png)



### **axios特点**

一、Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API
二、它可以拦截请求和响应
三、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据
四、安全性更高，客户端支持防御 XSRF

```vue
import VueAxios from 'vue-axios'// 把作用域对象挂载到vue实例上，方便直接用this去调用
```

### **MVVM**

MVVM的实现者 ---> 双向数据绑定   

MVVM 是 Model-View-ViewModel 的缩写。
	Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。
	View 代表UI 组件，它负责将数据模型转化成UI 展现出来。
	ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View，即连接视图和数据的中间件。ViewModel中内置了一个观察者，这个观察者观察两个维度，其一是观察视图的变化（当视图变了，就通知数据进行变化）；其二是观察数据的变化（数据变了，就通知视图进行变化）。MVVM通过VM实现了双向绑定。

在MVVM架构下，View 和 Model 之间不能直接通信，只能通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。

- ViweModel能够观察到数据的变化，并对视图对应的内容进行更新；
- ViewModel能够监听到视图的变化，并能够通知数据发生改变。

ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。

Vue.js就是MVVM的一个实现者，其核心就是实现了==DOM监听==和==数据绑定==。

#### 	MVC

Django框架遵循mvc设计，并有专有名词MVT。

**1.**M全拼为Model，主要封装对数据库层的访问，内嵌ORM框架，实现面向对象的编程来操作数据库，不用考虑数据库的差异性，简单配置就可以完成数据库切换。

**2.**V全拼为View，用于封装结果，内嵌了模板引擎，实现动态展示数据。封装html、css、js等内嵌模板引擎

**3.**C全拼为Controller，用于接收get或者post请求，处理业务逻辑，与Model和View交互，返回结果。

#### 	什么是MVC

MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户把对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。
如果前端没有框架，只使用原生的html+js，MVC模式可以这样理解。将html看成view;js看成controller，负责处理用户与应用的交互，响应对view的操作（对事件的监听），调用Model对数据进行操作，完成model与view的同步（根据model的改变，通过选择器对view进行操作）;将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。

#### 	MVVM与MVC区别

MVC 框架下网站的大量代码都被放在Controller，导致Controller代码臃肿；而且不利于单元测试，因为业务逻辑处理和视图更新操作会混杂在一起。MVVM是MVC的一个衍生模型，这里的 ViewModel 把业务逻辑处理、用户输入验证等跟视图更新操作分离开了。MVVM是数据驱动的，我们只需要关心数据的处理逻辑即可，它会通过模板渲染去单独处理视图的更新而不需要我们亲自去操作Dom元素。

MVVM与MVC两者之间最大的区别就是：MVVM实现了对View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素来改变View的变化，而是改变其属性后，该属性对应的View层数据会自动改变。
以Vue为例：

```
 <div id="vueDemo">  <p>{{ title }}</p>  <button v-on:click="clickEvent">hello word</button></div>var vueDemo = new Vue({      el: '#vueDemo',      data: {            title: 'Hello Vue!'      },      methods: {            clickEvent: function () {                  this.title = "hello word!"          }      }})
```

复制代码这里的html => View层，可以看到这里的View通过模板语法来声明式的将数据渲染进DOM元素，当ViewModel对Model进行更新时，通过数据绑定更新到View。
Vue实例中的data相当于Model层，而ViewModel层的核心是Vue中的双向数据绑定，当Model发生变化时View也可以跟着实时更新，同理，View变化也能让Model发生变化。
总的看来，MVVM比MVC精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作DOM元素。因为在MVVM中，View不知道Model的存在，Model和ViewModel也观察不到View，这种低耦合模式提高代码的可重用性。

### **vue路由的钩子函数**

首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。

beforeEach主要有3个参数to，from，next：
to：route即将进入的目标路由对象，
from：route当前导航正要离开的路由
next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。

### **vue中 key 值的作用**

​		答：当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。
==为什么使用v-for时必须添加唯一的key?==
​		key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

​		有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。

### **vue 计算属性computed**

​	答：在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。
​		**好处**：
​			①使得数据处理结构清晰；
​			②依赖于数据，数据更新，处理结果自动更新；
​			③计算属性内部this指向vm实例；
​			④在template调用时，直接写计算属性名即可；
​			⑤常用的是getter方法，获取数据，也可以使用set方法改变数据；
​			⑥相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。

### **computed 和 watch 的差异**

1. computed 是计算一个新的属性，并将该属性挂载到 vm（Vue 实例）上，而 watch 是监听已经存在且已挂载到 vm 上的数据，所以用 watch 同样可以监听 computed 计算属性的变化（其它还有 data、props）
2. computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，而 watch 则是当数据发生变化便会调用执行函数
3. 从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据；

### **VUE DATA**

#### **Vue 组件 data 为什么必须是函数**

​	• 每个组件都是 Vue 的实例。
​	• 组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他。

#### **组件中data什么时候可以使用对象**

​		组件复用时所有组件实例都会共享data，如果data是对象就会造成一个组件修改data以后会影响到其他所有组件，所以需要将data写成函数，每次用到就调用一次函数获得新的数据
​		当我们使用new Vue()的方式的时候，无论我们将data设置为对象还是函数都是可以的，因为new Vue()的方式是生成一个根组件，该组件不会复用，也就不存在共享data的情况

### **vue.$nextTick(callback)**

​	vue执行 DOM 的更新是异步的。当数据更新时，在 DOM 渲染之后，会自动执行 callback 函数。即 DOM 的渲染会在 js 的引擎清空事件队列后进行。nextTick的作用是处理 Vue 中 DOM 的异步更新之后的操作。

### **Vue中组件样式表的作用范围**

​	如果 vue 组件中的 style 标签没有带上 scope 属性，那么这个 style 的样式将会作用在整个页面中，而不只作用于当前组件中，加上 scoped 则会让样式只作用于当前组件中。



### **v-if与v-show的用法与区别**

[https://www.jianshu.com/p/2d3...](https://www.jianshu.com/p/2d3f584be910)

v-if、v-show是vue中两种常用的显隐方法，区别如下：

1.本质区别：

- v-if是动态地向DOM树中添加或者删除DOM元素；
- v-show本质是设置style样式display: none，v-show为真则不隐藏

2.编译区别

- v-if切换有一个局部的编译/卸载的过程，切换过程中会销毁和重建内部的事件监听和子组件。v-if初始值为false时，就不会进行编译；
- v-show其实就是控制css。v-show都会编译，初始值为false，只是将display设为none，但它也编译了。

v-show只编译一次，后面就是控制css，而v-if是不停地销毁和创建，因此v-show性能更好一些。

### **delete和Vue.delete删除数组的区别**

delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。 Vue.delete直接删除了数组 改变了数组的键值。

### **另一种方式实现vue的响应式原理**

Proxy在目标对象之前架设一层“拦截”，外界对该对象的访问都必须先通过这层拦截，因此提供一种机制，可以对外界的访问进行过滤和改写。

```
<input type="text" id="txt" /><div id="show"></div><script type="text/javascript">  var inp = document.getElementById('txt');  var show = document.getElementById('show')  var obj = {}  var objKey = 'text'; // 将键保存起来  // Object.defineProperty  Object.defineProperty(obj, objKey, {    get: function(){      return obj[objKey];    },    set: function(newVal){      show.innerHTML = newVal    }  })  inp.addEventListener('keyup', function(e){    obj[objKey] = e.target.value  })    // proxy的实现  const newObj = new Proxy(obj, {    get: function(target, key, receiver){      return Reflect.get(target, key, receiver);    },    set: function(target, key, value,receiver){      if(key === objKey){        show.innerHTML = value      }    }  })  inp.addEventListener('keyup',function(e){    newObj[objKey] = e.target.value;  })
```

Object.defineProperty的缺点：
1.不能检测到增加或删除的属性；
2.数组方面的变动，如根据索引改变元素，以及直接改变数组长度时的变化，不能被检测到。

关于资源打包

​	开发一个 vue 项目，标准的步骤：

1. 用 vue-cli 拉取一个项目骨架；
2. 安装依赖；
3. 使用 npm run dev 进入开发者模式。此时在开发者模式中，各种修改都能看到实时效果，这些内容实际上是由 vue-cli 进行打包并发布在 node.js 上的。但最后开发完之后要上生产，这些资源是需要我们手动部署在自己的服务器上的。那么哪些资源是需要我们手动部署的，因此通过 npm run build 命令来构建资源；
4. 使用 npm run build 命令来构建资源。会产生一个 dist 文件夹，里面包含静态资源。  

​         因此，在开发环境中，要想使用静态资源，首先通过 npm run build 命令来创建 dist 文件夹，然后将静态资源放入，再在 vue 的代码汇总，去该 /dist/ 文件夹内取资源即可。

## **git**

**Git 分布式版本管理工具**

​	相较于 svn，功能更强大，与 svn 不同点是 git 去中心化，每一个分支都是一个中心，并且支持本地仓库存储。

​	https://blog.csdn.net/weixin_30699831/article/details/101982286

### **git基本操作指令**

```bash
git status    # 查看本地状态
#untracked   还未记录，仅在工作区中
#modified  修改过，committed后的代码修改后会变成这个状态（cmd上该文件名显示为红色）
#staged    进行 git add 操作之后的状态，保存在了暂存区（cmd上该文件名显示为绿色）
#committed   进行 git commit 操作之后的状态，保存在了本地仓库（cmd上不会再显示该文件名）

git diff   # 对比当前工作区（红色）与暂存区（绿色）的内容更改
git diff --cached   # 对比暂存区（红色）与本地仓库（绿色）的内容更改

# 查看日志
git rev-parse HEAD   # 查看当前分支下的当前commitId
git log   # 查看所有的 commit 记录
git log filename  # 查看指定文件的所有 commit 记录（commit_id、author、date、commit记录的信息）
git log --pretty=oneline filename  # 查看指定文件的commit_id和记录信息（相比上一条显示信息较简单）
git log -p filename   # 查看指定文件每次提交的 diff
git log --graph   # 查看分支树
git show   # 查看当前commit下的提交的详情（author、date、diff、添加的内容等等）
git show commit_id  # 查看指定commit_id的所有修改
git show commit_id filename  # 查看指定commit_id下指定文件的修改

git ls-file -s   # 查看版本信息。会显示文件名及文件对应的版本号（commit-id）
git cat-file -p <commit-id>  # 查看当前分支下指定版本（commit-id）时的文件及修改内容

git branch 分支名    # 创建本地分支
# git2.23引入了 switch 和 restore。
# checkout既用来切换分支又用来恢复工作区文件，如此减少用户对checkout的认知负担
git checkout 分支名  /  git checkout -b 分支名  # 切换分支 / 创建分支 
git checkout 文件名   # 撤销文件中的内容的上次修改
git checkout <commit ID>   # 切换到当前分支的指定 commit 处
git switch 分支名  / git switch -c 分支名    # 切换分支 / 创建分支
# 相比于 git branch 创建分支，switch 创建的分支是创建并切换到新分支上。

# 删除本地分支
git branch -d 分支名    # 分支未合并时会不能删除
git branch -D 分支名    # 强制删除
# 恢复一个误删的分支dev  
#（删除分支只是删除了指向内容的指针，需要做的是找回指针） 3步  当前在master分支上操作
git reflog		# 打印出操作记录
git checkout		# 进入到master上之前创建dev分支的commit处
git checkout -b <branch-name>  # 创建出删除的分支

# 合并分支
git merge <branch-name>    # 一般在主分支上操作，将branch-name分支合并到主分支上来，最终呈树状结构 
git rebase <master-name>    # 在分支上操作，将当前分支合并到master-name（主分支）的末尾处接上。
# merge. 优点：比较容易理解；缺点：历史可能会乱。适合大部分情况/合作者相互熟悉，并且频繁交流
# rebase. 优点：可以按作者清晰区分commit；缺点：时间顺序会被打乱。理解起来较复杂。
#  			rebase适合大企业多个团队，互相交流较少，各自集中开发的情况。
# 冲突解决
# 通过 merge/rebase 合并发生冲突，并手动解决冲突制后，需要重新git add 解决的冲突文件，再commit并push。 
# ==== 到 >>>>>demoxx 之间的修改是在分支demoxx中做的，  ===== 到 <<<<<< 之间的修改是在当前分支中做的

# 回退 (回退到某一个 commit)
git revert 版本号  
# 把要回滚的版本覆盖（拿一个新的版本覆盖一个老的版本），回退到版本N时，版本号要填N的上一个版本的版本号
# 回退了，但会有回退记录
git reset --hard 版本号  
# 回退，且不会有回退记录（回退到版本号对应版本）。之后push的时候一般情况下会冲突，加--force强制操作
# git reset 有4种方式  --mixed（HEAD与file_path）、--soft、--hard
# 记commit history（本地仓库）、Staged Snapshot（暂存区）、Working Directory（工作区）分别为1、2、3
git reset --mixed <file_path>    # 操控2
git reset --mixed HEAD    # 操控1、2
git reset --soft <file_path> 或 HEAD    # 操控1
git reset --hard <file_path> 或 HEAD    # 操控1、2、3

git remote -v    # 查看远程仓库情况
git remote add origin git@github.com:AmmaleH/FirstRep.git    # 连接远程仓库
git push --set-upstream origin 远程分支名    # 关联远程分支，并推送代码
git push origin 本地分支名:远程分支名   # 将本地分支推送到远程仓库
git fetch origin 远程分支名x:本地分支名x    # 将远程分支拉取到本地仓库
# 删除远程分支
git push origin --delete 分支名
git push origin :分支名

# 多人协作开发时，远程仓库呗其他人更新了，自己的本地仓库没更新，同步更新到本地。（两种方法）
git fetch      # 从远程库获取代码
git merge origin/master   # 无冲突时直接合并，有冲突时会提醒手动解决冲突
git pull    # 相当于上面两次步骤 （无冲突时直接完成）


git push origin 分支名 --force

```

​	git解决冲突目前已经遇到的有三个场景：

​		1.合并分支； 2.回退（reset）后再重新推到远程时；3.从远程拉代码下来时（其实也是涉及合并分支，fetch+merge = pull）。前面两个push 时必须加 -f，强制推送。

### **git中遇到的问题**

​	**问题1（push推送错误解决）：**Unable to access ‘https://github.com仓库.git/‘: OpenSSL SSL_read: Connection was reset, errno 10054

​			一般是因为本地使用了代理，会发生这种错误。

​	**解决：**输入  git config --global http.sslVerify "false"   或     git config --global http.sslBackend "openssl"（只能输入一次解决一次）。其他解决方法：关闭代理或者输入命令  git config --global --unset-all remote.origin.proxy

​	**问题2：**fatal: Not a valid object name: 'master'

​	**原因及解决：**本地还没有创建master，可以先执行 git branch，看有没有本地分支，若没有，则需要先新建一个文件，add并commit。在执行 git branch 可以发现本地会有 master 分支了，再执行 git branch 分支名，来新建一个分支。

​	**问题3：**fatal: 'origin' does not appear to be a git repository.     fatal: Could not read from remote repository.

​	**原因及解决：**没有找到对应的远程仓库（一般是发生在切换到一个新的文件夹里，初始化git时），可以添加新的远程仓库

```bash
git remote add origin 仓库名（git@github.com:AmmaleH/FirstRep.git）
```

​	**问题4：**fatal: refusing to merge unrelated histories（在git pull 拉取远程代码的时候发生的）

​	**原因及解决：**当前所处的本地分支与 push/pull 的远程分支没有关系，会遇到该问题。解决：将当前分支 git checkout 到与远程分支相同的分支。或者在操作命令的后面加 --allow-unrelated-histories。

​	**问题5：**fatal: The current branch master has no upstream branch.

​	**原因及解决：**没有将本地的分支与远程仓库的分支进行关联。主要原因是远程仓库太多且分支较多。在默认情况下，git push 时一般会上传到 origin 下的 master 分支上，然而当 repository 的 branch 过多，而又没有设置关联时，git 会无法判断 push 的目标。两种解决方法：

1. git push --set-upstream origin master       注：origin为远程仓库标签，可以用 git remote -v 查看指向的远程仓库。master为要设置关联的远程仓库的分支名，git branch -c 可查看所有分支（红色为远程分支）。
2. git push -u origin master     注：第一条命令要保证远程分支存在，不存在则无法关联；第二条命令即使没有要关联的远程分支，也会自动创建一个出来，以实现关联。



## **计算机网络**

### **cookie**

​	cookie是浏览器保存在用户电脑上的一小段文本，用来保存用户在网站上的必要的信息。Web网页或服务器告诉浏览器按照一定的规范存储这些信息，并且在以后的所有请求中，这些信息就会自动加在http请求头中发送给服务器，服务器根据这些信息判断不同的用户。并且cookie本身是安全的。

​	cookie的字段：name、value、domain（访问这个域名才会携带这个域名对应的cookie）

#### 

- ## 网络HTTP

  https://juejin.cn/post/6844903459662069773

  

- ## 网络TCP/IP

  https://juejin.cn/post/6844903459259416589

  

- ## http缓存

  https://juejin.cn/post/6844903634002509832

### **数字证书**

服务器：发送自身私钥加密的内容、CA（证书机构）私钥对摘要进行加密生成的签名以及服务器公钥。摘要是对内容进行哈希求得的散列值。

客户端：用服务器公钥解密获得服务器发送过来的内容A，并判断该内容A是否被篡改。判断方式：用CA公钥解密签名得到摘要1，自己再对内容A进行相同的哈希算法得到摘要2，若摘要1 == 摘要2，则未被篡改。

### **HTTPS与HTTP的一些区别**

1. HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。

2. HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。

3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4. HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

   ==SSL/TLS==协议是为了解决这三大风险而设计的，希望达到：

   > （1） 所有信息都是**加密传播**，第三方无法窃听。
   >
   > （2） 具有**校验机制**，一旦被篡改，通信双方会立刻发现。
   >
   > （3） 配备**身份证书**，防止身份被冒充。

![img](https://upload-images.jianshu.io/upload_images/138606-0360ca017b6f5eb7.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

#### HTTP1.0和HTTP2.0的区别

在 HTTP/1.0 中默认短连接，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。HTTP/1.1中默认长连接，Connection: keep-alive 。

https://www.jianshu.com/p/be29d679cbff

#### HTTP1.0和HTTP1.1的一些区别

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

1. **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
2. **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
5. **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点

#### HTTP2.0和HTTP1.X相比的新特性

1. **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
2. **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
3. **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
4. **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。

### 	**TCP三次握手、四次挥手**

​	https://juejin.cn/post/6936807481301532702#heading-9

**控制字段：**

​	URG：紧急指针有效    ACK：确认是有效的    PSH：请求推送    RST：连接复位    SYN：同步序号    FIN：终止连接

三次握手之所以是三次是保证client和server均让对方知道自己的接收和发送能力没问题而保证的最小次数。

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9245c0aec1545f18e4533d1abd18d20~tplv-k3u1fbpfcp-zoom-1.image?imageslim" alt="img" style="zoom:67%;" />

> 说明：
>
> - 同步SYN，在连接建立时用来同步序号。当SYN=1，`ACK`=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，`ACK`=1；
> - 确认`ACK`，仅当`ACK`=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把`ACK`置1；

其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的ACK都会对这个seq进行加一来进行确认。

Q 1：为什么要三次握手？

**三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、自己接收正常，对方发送、对方接收正常；Server 确认了：对方发送正常，自己接收正常

第三次握手：Client 确认了：自己发送、自己接收正常，对方发送、对方接收正常；Server 确认了：自己发送、自己接收正常，对方发送、对方接收正常

Q 2：第2次握手传回了ACK，为什么还要传回SYN？

接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”

Q 3：不能二次握手吗，第三次握手的重要性？

> 假设TCP连接不需要第三次握手，即只要Server发出确认报文后，TCP就建立连接（两次握手），那么会出现什么问题？

> <u>Server端会因**接收了早已失效的报文**，从而一直等待客户端的请求，最终导致死锁，资源浪费。</u>
>
> 什么是早已失效的连接请求报文段？
>
> 当客户端发出的第一个连接请求报文段无丢失，而是在某个网络节点长时间滞留了，导致延误到连接释放后的某个时间才到服务器，这种连接请求报文段是无效的。
>
> 当TCP连接只需要两次握手时，服务器端接收到了无效的连接请求报文段，就会误认为是客户端发出的一个新的连接请求，于是像客户端发出了确认报文段，同意建立TCP请求。因为假设了只需要两次握手，那么此时TCP连接就已经建立了。但是对客户端来说，它并没有发出建立连接的请求，所以不会向服务器端发送数据。但对服务器端了来说，因为它误以为客户端发出了建立连接的请求，所以它会一直等待客户端发送数据，最终导致**死锁状态**。
>
> 为了解决这个问题，就需要采用**第三次握手**，当服务器端发出了确认请求报文段之后，客户端并不会向服务器端的确认报文段发出确认，服务器收不到客户端发来的确认信息，就知道客户端并没有发出建立连接的请求，就不会一直等待客户端发送数据。所以三次握手就能确认双发收发功能都正常，缺一不可。

SYN洪泛攻击：

- 从上可看出：服务端的TCP资源分配时刻 = 完成第二次握手时；而客户端的TCP资源分配时刻 = 完成第三次握手时
- 这就使得服务器易于受到`SYN`洪泛攻击，即同时多个客户端发起连接请求，从而需进行多个请求的TCP连接资源分配

##### TCP释放连接的四次挥手

![四次挥手](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36b991e42d7f4b008b4dc74b7f55fc1b~tplv-k3u1fbpfcp-zoom-1.image)

断开一个 TCP 连接则需要“四次挥手”：

- 客户端-发送一个 FIN,设置为1，用来关闭客户端到服务器的数据传送
- 服务器-收到这个 FIN，它发回一 个 `ACK`，确认序号为收到的序号加1 。和 `SYN` 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送一个FIN给客户端
- 客户端-发回 `ACK` 报文确认，并将确认序号设置为收到序号加1

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

#### Q 1：为什么TCP释放连接需要四次挥手？

> TCP连接提供全双工通信，即客户端收发信息，服务器端也可以收发信息。
>
> TCP释放连接的目的是达到双方都无法接收信息。假设此时采用两次挥手，即客户端像服务器端发送了释放连接请求，并且服务器端返回确认释放连接信息时，此时，TCP连接是处于**半关闭状态**，即客户端无法发送信息给服务器端，但仍然可以接收来自服务器端的信息（服务器端可以发信息给客户端），因此需要再进行二次握手，即服务器端向客户端发送释放连接的请求，并且客户端向服务器端发送确认释放连接的请求，才真正完成释放（双向）。
>
> 补充：客户端再关闭连接前需要等待2`MSL`（`MSL`是最长报文段寿命 muximum segment lifetime）时间。

#### Q 2： 为什么需要等待2`MSL`时间（TIME-WAIT）？ 

① 客户端发送的最后一个连接释放请求报文可能丢失，当服务器端接收不到连接释放确认报文时，不会进入关闭状态，但会超时重发连接释放报文。等待2MSL时间就是为了保证客户端发送的最后一个连接确认报文能够到达服务器。假设客户端没有等待2`MSL`时间就直接关闭连接，当客户端最后一个确认报文丢失时，服务器超时重发释放连接请求，因为此时客户端连接已经关闭，因此接收不到服务器发送的信息，服务器一直接收不到客户端发送的确认信息，导致**无法进入关闭状态**。

解决这个方法就是让客户端关闭连接前等待2`MSL`时间，客户端发送最后一个确认报文段后，启动2`MSL`计时器。若最后一个报文段丢失，服务器超时重发，客户端也能再次接收到服务器的信息，并且重新发送释放连接确认报文段。

② 客户端发送了最后1个连接释放请求确认报文后，再经过2`MSL`时间，则可使本连接持续时间内所产生的所有报文段都从网络中消失。防止**早已失效的连接请求报文** 出现在本连接中。

#### Q3.time-wait过多怎么办，可不可以不要time-wait？

​			timewait快速回收和重用。快速回收：通过修改参数启用快速回收，此时timewait只有一个rto的时间。重用有两个条件，1.新连接的初始序列号比TW老连接的末序列号大。2.如果使用了时间戳，那么新到来的连接的时间戳比老连接的时间戳大。并且同一个ip和端口号的才能重用。

#### 流量控制与差错控制

**发送窗口** = min（拥塞窗口 cwnd，接收窗口 rwnd） 

**接收窗口**（rwnd） =  缓存大 小 - 正在等待被拉取的字节数

**拥塞窗口**：TCP处理拥塞一般是三个阶段：慢开始、拥塞避免、拥塞检测。

慢开始（slow start）：指数增大。cwnd从一个最大报文段的长度（MSS）开始，直至到达门限（ssthresh）为止。

拥塞避免（congestion avoidance）：线性增大。每过一个RTT，拥塞窗口增加一个报文段大小，直至检测到拥塞为止。

拥塞检测（congestion detection）：乘法减小。发送方需要重传一个报文段 -> 拥塞被检测到了。两种情况：

	1. RTO计时器超时。出现拥塞的可能性较大，TCP会有较强烈的反应：a.把门限值设为当前窗口的一半；b. 把cwnd重新设置为一个报文段大小；c. 再次从慢开始阶段开始。
	2. 收到三个重复的ACK。（快重传和快恢复FRR）。TCP反应较弱。a. 把门限值设置为当前窗口的一半；b. 把cwnd设置为门限值（有的实现是 门限值+3个报文段大小）；c. 开始拥塞避免阶段。 

重传

停止等待协议：流量控制通过迫使发送方等待确认来实现（发送方每发送一个分组，在发送下一个分组之前要先等待一个确认）。发送接收两方都使用了大小为1的滑动窗口。差错控制通过丢弃损坏的分组并让发送方在RTO计时器超时后重传未确认的分组来实现。

回退N步协议：会丢弃所有失序的分组，从第一个失序的分组开始重传。

选择重传（Selective-Repeat SR）协议：确认号定义了无差错地接收到的一个分组的序号。它只会重传丢失的分组。

RTT：一个报文段到达终点并收到他的确认所需的时间；

RTO：超时重传时间。

1. RTO之后的重传：发送方TCP为每一条连接设置一个RTO计时器，当超时（计时器时间到），TCP发送队列中最前面（序号最小）的报文段；（这种情况下网络拥塞比较严重了）
2. 三个连续重复的ACK报文段之后的重传（快重传）：不用等待RTO计时器超时，发送方连续收到三个相同序号的ACK时，会立即重传丢失的报文段。

### 	**get和post的区别（==重要==）**

https://juejin.cn/post/6844903489127219214

1. GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。并非它们的本身区别。

2. GET方式提交的数据有长度限制，则POST的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。也不是GET和POST本身的区别。

3. POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。
4. POST 请求比 GET 请求要占用更多资源。从性能上说，发送相同数量的数据，GET 请求比 POST 请求要快两倍。

GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别，上面的只是在使用上的区别。

> 什么是幂等性？幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。

正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。

==GET，PUT，DELETE都是幂等操作，而POST不是==，以下进行分析：

首先GET请求很好理解，对资源做查询多次，此实现的结果都是一样的。 
 PUT请求的幂等性可以这样理解，将A修改为B，它第一次请求值变为了B，再进行多次此操作，最终的结果还是B，与一次执行的结果是一样的，所以PUT是幂等操作。 
 同理可以理解DELETE操作，第一次将资源删除后，后面多次进行此删除请求，最终结果是一样的，将资源删除掉了。

POST不是幂等操作，因为一次请求添加一份新资源，二次请求则添加了两份新资源，多次请求会产生不同的结果，因此POST不是幂等操作。

#### 	**常见状态码**

https://juejin.cn/post/6844903890840715271

1XX	Informational（请求正在处理）

2XX	Success（请求成功）

3XX	Redirection（重定向）	需要进行附加操作以完成请求

4XX	Client Error（客户端错误）

5XX	Server Error（服务器错误）

200 OK 请求正常处理

204 请求处理成功 但是没有任何资源返回给客户端(一般用于只需客户端向服务端发送消息)

206 对资源的某一部分请求 响应报文中包含由 Content-Range 指定范围的实体内容

301永久重定向 如果把资源对应的URI保存为书签，则此时书签会根据Localtion首部字段提示的URI重新保存

302 临时重定向 临时地从旧地址A跳转到地址B

303 和301，302类似 当使用post方法访问一个资源时，把客户端以get的方式重定向到对应的URI，返回303状态码。

​		表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。

304 资源已经找到，但是不满足条件，所以不把资源返回给客户端。常用于协商缓存。

400 请求报文内有语法错误

401 该状态码表示发送的请求需要通过HTTP认证，初次收到401响应浏览器弹出认证的对话窗口。若收到第二次401状态码，则说明第一次验证失败。

403 请求资源的访问被服务器拒绝，一般是未获得文件系统的访问权限，访问权限出现问题。

404 服务器上找不到请求资源 或路径错误

405 请求方法被服务端识别，但是服务端禁止使用该方法。可以用OPTIONS来查看服务器允许哪些访问方法

500 服务器端在执行请求时出错，一般是因为web应用出现bug

502 代理服务器或网关从上游服务器中收到无效响应

503 服务器暂时处于超负载或停机维护，目前无法处理请求

<u>**301和302的区别。**</u>

  301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（**用户看到的效果就是他输入的地址A瞬间变成了另一个地址B**）——**这是它们的共同点**。
  他们的不同在于。301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301

**<u>重定向原因：</u>**

1. 网站调整（如改变网页目录结构）；
2. 网页被移到一个新地址；
3. 网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。

### 常见的HTTP请求方式

**1、GET方法**
GET方法用于使用给定的URI从给定服务器中==检索信息==，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响。
在GET请求的URL中发送查询字符串（名称/值对），需要这样写：
说明：
GET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中；且GET请求有长度限制，仅用于请求数据（不修改）。
注：因GET请求的不安全性，在处理敏感数据时，绝不可以使用GET请求。

**2、POST方法**
POST方法用于将数据发送到服务器以==创建或更新资源==，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。
POST请求永远不会被缓存，且对数据长度没有限制；我们无法从浏览器历史记录中查找到POST请求。

**3、HEAD方法**
HEAD方法与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容。

**4、PUT方法**
PUT方法用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容。
它会将包含的元素放在所提供的URI下，如果URI指示的是当前资源，则会被改变。如果URI未指示当前资源，则服务器可以使用该URI创建资源。

**5、DELETE方法**
DELETE方法用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。

**6、CONNECT方法**
CONNECT方法用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信（HTTPS）。

**7、OPTIONS方法**
OPTIONS方法用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略。

**8、TRACE方法**
TRACE方法用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量。

### HTTP 与 TCP之间的相关问题

TCP四大特性：可靠传输、流量控制、拥塞控制、连接管理。

**1.现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？**

http1.0时默认为短连接，在服务器响应完之后会断开连接。但这样每次请求都要建立和断开连接，开销太大。之后http1.1默认为长连接（connection: keep-alive）。长连接并不是永久，而是维持一段时间（保活计时器）。

**2.一个 TCP 连接可以对应几个 HTTP 请求？**

一个TCP连接可以对应多个HTTP请求。

**3.一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？**

HTTP1.1存在一个问题，单个TCP连接同一时刻只能处理一个HTTP请求。意思是说，一个TCP连接中的HTTP请求生命周期不能重叠，HTTP1.1规范中有Pipelining来解决这问题，但浏览器是默认关闭的。

HTTP1.1中浏览器提高页面下载效率的方法：1.维护已有的TCP链接，顺序执行HTTP请求；2.建立多个TCP连接。

**4.为什么有的时候刷新页面不需要重新建立 SSL 连接？**

长连接。TCP不需要重新建立，SSL自然也不需要重新建立。（SSL运行在TCP之上）。

**5.浏览器对同一 Host 建立 TCP 连接到数量有没有限制？**

有。Chrome最多对同一host建立 6 个连接，不同浏览器有一些区别。

### 长短轮询和长短连接的区别

第一个区别是决定的方式，一个TCP连接是否为长连接，是通过设置HTTP的Connection Header来决定的，而且是需要两边都设置才有效。而一种轮询方式是否为长轮询，是根据服务端的处理方式来决定的，与客户端没有关系。

第二个区别就是实现的方式，连接的长短是通过协议来规定和实现的。而轮询的长短，是服务器通过编程的方式手动挂起请求来实现的。

### 	**常见HTTP请求头响应头**

### 一、常用的http请求头

1.Accept

- **Accept: text/html** 浏览器可以接受服务器回发的类型为 text/html。
- **Accept: \*/\***  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。

2.Accept-Encoding

- **Accept-Encoding: gzip, deflate** 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。

3.Accept-Language

- **Accept-Language:zh-CN,zh;q=0.9** 浏览器申明自己接收的语言。

4.Connection

- **Connection: keep-alive** 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
- **Connection: close** 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。

5.Host（发送请求时，该报头域是必需的）

- **Host:www.baidu.com** 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。

6.Referer

- **Referer:https://www.baidu.com/?tn=62095104_8_oem_dg** 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。

7.User-Agent

- **User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36** 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。

8.Cache-Control

- **Cache-Control:private** 默认为private 响应只能够作为私有的缓存，不能再用户间共享
- **`\**Cache-Control:public\** `**响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.
- **Cache-Control:must-revalidate** 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。
- **Cache-Control:no-cache** 响应不会被缓存,而是实时向服务器端请求资源。
- **Cache-Control:max-age=10** 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。
- **`Cache-Control:no-store `**在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。

9.Cookie

Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。

10.Range（用于断点续传）

- **Range:bytes=0-5** 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。

### 二、常用的http响应头

1.Cache-Control（对应请求中的Cache-Control）

- **Cache-Control:private** 默认为private  响应只能够作为私有的缓存，不能再用户间共享
- ***\*Cache-Control:public\**** 浏览器和缓存服务器都可以缓存页面信息。
- **Cache-Control:must-revalidate**  对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。
- **Cache-Control:no-cache**  浏览器和缓存服务器都不应该缓存页面信息。
- **Cache-Control:max-age=10** 是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。
- **Cache-Control:no-store** 请求和响应的信息都不应该被存储在对方的磁盘系统中。

2.Content-Type

- **Content-Type：text/html;charset=UTF-8** 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。

3.Content-Encoding

- **Content-Encoding:gzip** 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。

4.Date

- **Date: Tue, 03 Apr 2018 03:52:28 GMT** 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。

5.Server

- **Server：Tengine/1.4.6** 这个是服务器和相对应的版本，只是告诉客户端服务器信息**。**

6.Transfer-Encoding

- **Transfer-Encoding：chunked** 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。

7.Expires

- **Expires:Sun, 1 Jan 2000 01:00:00 GMT** 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。

8.Last-Modified

- **Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT** 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)

9.Connection

- **Connection：keep-alive** 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。

10.Etag

- **ETag: "737060cd8c284d8af7ad3082f209582d"** 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。

11.Refresh

- **Refresh: 5; url=http://baidu.com** 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。

12.Access-Control-Allow-Origin 

- **Access-Control-Allow-Origin: \***  *号代表所有网站可以跨域资源共享，如果当前字段为*那么Access-Control-Allow-Credentials就不能为true
- **Access-Control-Allow-Origin: www.baidu.com** 指定哪些网站可以跨域资源共享

13.Access-Control-Allow-Methods

- **Access-Control-Allow-Methods：GET,POST,PUT,DELETE** 允许哪些方法来访问

14.Access-Control-Allow-Credentials

- **Access-Control-Allow-Credentials: true** 是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true

15.Content-Range

- **Content-Range: bytes 0-5/7877** 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。

### 	

## **操作系统**

——————————————————————————————————————————————————-——--——-———

#### Q：**操作系统的特征**

- 并发：指两个或多个事件在同一时间间隔内发生，宏观上是同时发生的，微观上是交替发生的
- 共享：资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用
- 虚拟：把一个物理上的实体变为若干个逻辑上的对应物
- 异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进

#### Q：**用户态与内核态**

为了安全，用户进程是受限的，它不能随意访问资源、获取资源。所以，由内核进程负责管理和分配资源，它具有最高权限，而用户进程使用被分配的资源，所以 CPU划分出两个权限等级 -- 用户态和内核态。

1. 用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。
2. 内核态(kernel mode)：可以简单的理解内核态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。

**状态转换：**

- 系统调用：用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作
- 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
- 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

#### Q：**用户空间与内核空间**

对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。也就是说一个进程的最大地址空间为 4G。

为了保证内核的安全，现在的操作系统一般都强制用户进程不能直接操作内核。具体的实现方式基本都是由操作系统将虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用户空间。针对 Linux 操作系统而言，最高的 1G 字节(从虚拟地址 0xC0000000 到 0xFFFFFFFF)由内核使用，称为内核空间。而较低的  3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)由各个进程使用，称为用户空间。

- 每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用。换句话说就是， 最高 1G 的内核空间是被所有进程共享的！

#### Q：**进程和线程的区别**

1. 进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）
2. 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
   而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
3. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。
4. 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

#### Q：**协程**

​		协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行），执行一个子任务时可以被停止，转去执行另一个，然后再回来接着执行。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

#### Q：**协程和线程的区别**

极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；

不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。

#### Q：**进程状态**

- 创建状态：对应于进程被创建时的状态，尚未进入就绪队列
- 就绪状态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
- 运行状态：占用CPU，并在CPU上运行
- 阻塞状态：因等待某一事件而暂时不能运行
- 终止状态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。

> 创建态 -> 就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许
>
> 就绪态 -> 运行态：CPU空闲时选择一个就绪进程运行
>
> 运行态 -> 就绪态：运行时间片到，或出现有更高优先权进程
>
> 运行态 -> 阻塞态：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如发生了I/O请求
>
> 阻塞态 -> 就绪态：申请的资源被分配，或等待的事件发生，等待分配时间片
>
> 运行态 -> 终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结

#### Q：**进程通信**

- 管道

  管道是半双工通信方式，数据只能单向流动，存在于内存中。实质是内核利用环形队列的数据结构在内核缓冲区中的一个实现。各进程要互斥地访问管道。数据以字符流的形式写入管道，写端每次都将数据写入管道缓冲区的末尾，而读端每次都从管道缓冲区的头部读出数据。

  - 匿名管道通信：只能在具有公共祖先的两个进程之间使用，只存在于内存中的文件

  - 命名管道通信：它提供了一个路径名与之关联，以命名管道的文件形式存在于文件系统中，这样，即使与命名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过命名管道相互通信，因此，通过命名管道不相关的进程也能交换数据。命名管道的名字存在于文件系统中，内容存放在内存中。

- 消息队列

  消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列允许一个或多个进程向它写入与读取消息。克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

- 信号

  信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。

  信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了那些系统事件。

  如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞取消时才被传递给进程。

- 信号量

  信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

  信号量定义了两种操作，p操作和v操作，若此信号量的值为正，则进程可以使用该资源，否则，若此信号量的值为0，则进程进入休眠状态，直到信号量的值大于0。p操作为申请资源，会将数值减去M。v操作是归还资源操作，告知归还了资源可以用这部分。

- 共享内存

  共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

- 套接字（可不说）

#### Q：**几种IPC方式优缺点**

- 如果用户传递的信息较少，或者只是为了出发某些行为。**信号**是一种简洁有效的通信方式。但若是进程间要求传递的信息量较大或者存在数据交换的要求，就需要考虑别的通信方式了。
- 消息队列允许任意进程通过共享队列来进行进程间通信。并由系统调用函数来实现消息发送和接收之间的同步。从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用相对方便。但是消息队列中信息的复制需要耗费CPU时间，不适宜信息量大或频繁操作的场合。
- 消息队列与管道方式的区别在于，消息队列可以实现**多对多**，并需要在**内存**中实现，而管道可以在**内存或磁盘**上实现。
- 共享内存无须复制，**信息量大**是其最大的优势。但是需要考虑**同步问题**。

#### Q：**进程调度算法**

- 时间片轮转法

  抢占式。按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，若进程未在一个时间片内执行完，则将剥夺CPU并分配给另一个进程。公平响应快。但如果时间片太小，会导致过多的进程切换浪费资源，而时间片太长又可能引起对短的交互请求的响应时间变长。不会导致饥饿

- 最短剩余时间优先

  最短进程优先的抢占式版本，选择剩余运行时间最短的进程运行。每当有进程加入就绪队列改变时就需要调度，如果 **新到达的进程运行时间比当前运行的进程剩余时间更短**，则当前进程就被挂起，运行新的进程。

- 先进先出服务

  非抢占式，按照请求CPU的顺序使用CPU。公平，算法实现简单，但排在长作业后面的短作业需要等待很长时间。不会导致饥饿

- 最短进程优先

  非抢占式，所要求的服务时间最短的进程优先得到服务。每次调度时选择**当前已到达且运行时间最短**的进程。对长作业不利，会导致长作业饥饿

- 最高响应比优先

  非抢占式。在每次调度时先计算各个进程的响应比，选择响应比最高的进程运行。响应比 = (等待时间+要求服务时间)/要求服务时间

- 优先级调度算法

  每个进程都有各自的优先级，调度时选择优先级最高的。可能会导致饥饿

- 多级反馈队列调度算法

  抢占式。是对其他调度算法的折中权衡。可能会导致饥饿

  > 规则：
  >
  > 1）设置多级就绪队列，各级队列优先级从高到低，时间片从小到大。
  >
  > 2）新进程到达时先进入第1级队列，按先进先出原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列的队尾。如果此时已经在最下级队列，则重新放回最下级队列队尾
  >
  > 3）只有当第k级队列为空时，才会为k+1级队头的进程分配时间片
  >
  > 4）在第k级队列的进程运行过程中，若更上级的队列中进入一个新进程，由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回原队列队尾

#### Q：**进程同步**

指为完成某种任务而建立的两个或多个进程，这些进程在合作的过程中需要协调工作次序进行有序的访问而出现等待

- 信号量

  用于进程间传递信号的一个整数值。在信号量上只有三种操作可以进行：初始化，P操作和V操作

  P操作(递减操作)可以用于申请资源，对整数值进行减操作，V操作(增加操作)用于释放资源，对整数值进行加操作。

- 管程

  管程是由一个或多个过程、一个初始化序列和局部数据组成的软件模块，基于类似PV操作实现资源同步。在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。**任意时刻管程中只能有一个活跃进程**

- 消息传递

  一个进程以消息的形式给另一个指定的目标进程发送消息。进程通过执行send发送消息，receive原语接收消息，receive原语中指明发送消息的源进程和消息。  


#### Q：**对临界资源的互斥访问，可分为以下部分**

1. 进入区：负责检查是否可以进入临界区，若可进入，则应设置正在访问临界资源的标志（可理解为上锁），以阻止其他进程同时进入临界区
2. 临界区：访问临界资源的那段代码
3. 退出区：负责解除正在访问临界资源的标志（可理解为解锁）
4. 剩余区：做其他处理

原则：空闲让进、忙则等待、有限等待、让权等待

#### Q：**进程互斥的方式**

指两个或多个进程访问临界资源时只能一个进程访问，其他进程等待

- 单标志法

  每个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。不满足空闲让进原则

- 双标志先检查

  设置一个布尔型数组，数组中各个元素用来标记各进程想进入临界区的意愿。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志设为true，之后开始访问临界区。违反忙则等待原则

- 双标志后检查

  上述算法的改进，先上锁，再检查。违背了空闲让进和有限等待原则

- Peterson 算法

  进程主动让对方先使用临界区

<img src="C:/Users/lbj/Desktop/学习笔记/面试准备.assets/image-20210718164908111.png" alt="image-20210718164908111" style="zoom:50%;" />

#### Q：**线程同步**

线程同步是两个或多个共享关键资源的线程的并发执行

- 互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
- 信号量(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
- 事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操

#### Q：**什么是进程上下文**

进程上下文实际上是进程执行活动全过程的静态描述。我们把已执行过的进程指令和数据在相关寄存器与堆栈中的内容称为上文，把正在执行的指令和数据在寄存器和堆栈中的内容称为正文，把待执行的指令和数据在寄存器与堆栈中的内容称为下文。

#### Q：**上下文切换**

在处理器执行期间，运行进程的信息被存储在处理器的寄存器和高速缓存cache中，执行的进程被另载到寄存器的数据集被称为上下文。

在进程切换过程中，先存储运行进程的上下文，然后将下一个要运行的进程的上下文恢复到寄存器中。这个过程被称为上下文切换。

一般不能有太多的上下文切换，因为CPU要刷新寄存器和高速缓存，以便释放空间给新的进程。可能会导致性能问题

#### Q：**为什么进程上下文切换比线程上下文切换代价高？**

进程切换分两步：

1. 切换页目录以使用新的虚拟地址空间
2. 切换内核栈和硬件上下文

```
进程的上下文切换具体过程：
1.接收到切换信号，挂起进程，记录当前进程的虚拟内存、栈等资源存储;
2.将这个进程在 CPU 中的上下文状态存储于起来;
3.然后在内存中检索下一个进程的上下文;
4.并将其加载到 CPU的寄存器中恢复;
5.还需要刷新进程的虚拟内存和用户栈;
6.最后跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。
```

对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2步是进程和线程切换都要做的

切换的性能消耗：

线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor's Translation Lookaside Buffer (TLB)）会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题

#### Q：**触发进程切换的场景**

1. CPU时间片到了就会切换
2. 系统在资源不足(如内存不足)时，等到资源满足后才可以允许，这个时候进程也会被挂起，系统会调度其他进程
3. 当进程通过sleep函数将自己挂起，系统也会重新调度
4. 有更高优先级的进程运行时，当前进程会被挂起
5. 当硬件发生中断时，CPU上的进程会被中断挂起

#### Q：**上下文切换的性能优化**

进程上下文切换：

1. 单CPU进程上下文，尽量切换次数少些   

   这个可以通过调整优先级，让进程分得的时间更多些，时间片多，则切换少

2. 跨CPU进程上下文切换，这个是可以避免的   

   1. 写代码时，进程绑定到特定的CPU核里，那么就不会涉及到跨CPU切换
   2. 可参考nginx的做法

线程上下文切换：

1. 线程也可以指定绑定到核中，可以防止跨CPU消耗
2. 线程能使用无锁方法，尽量使用无锁，无锁队列等
3. 线程数量尽可能和适量，太多的线程会导致无用切换消耗
4. 涉计到多线程，尽量设计的简单些

#### Q：**哲学家就餐问题**

1. 问题描述

   有五个哲学家围在一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五根筷子，他们的生活方式是交替的进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，如果筷子已在他人手上，则需等待，只有在他拿到两支筷子时才能进餐。进餐完毕后，放下筷子继续思考。

2. 问题分析

   一共有五个哲学家，也就是五个进程；五只筷子，也就是五个临界资源；因为哲学家想要进餐，必须要同时获得左边和右边的筷子，这就是要同时进入两个临界区（使用临界资源），才可以进餐。

3. 解决方法

   - 方法一：至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用餐完毕后能释放他占用的筷子，从而使别的哲学家能够进餐；

     ```java
     semaphore[] mutex = {1,1,1,1,1}; 		//初始化信号量
     semaphore count = 4;	//控制最多允许四位哲学家同时进餐
     
     void philosopher(int i){
       while(true) {
         //thinking		               // 思考
         wait(count);                   // 请求进餐
         wait(mutex[i]);                // 请求左手边的筷子
         wait(mutex[(i + 1) % 5]);      // 请求右手边的筷子
         //...
         //eat			//进餐
         //...
         signal(mutex[(i + 1) % 5]);    // 释放右手边的筷子
         signal(mutex[i]);              // 释放左手边的筷子
         signal(count)；                // 释放信号量
       }
     }
     ```

   - 方法二：仅当哲学家的左、右两支筷子可用时，才允许他拿起筷子；

     ```java
     semaphore[5] chopstick = {1, 1, 1, 1, 1};
     void philosopher(int i) {
     	while(true) {
     		think();
     		Swait(chopstick[i], chopstick[(i  +1) % 5]);     // 判断哲学家左边和右边的筷子是否同时可用
     		eat();
     		Ssignal(chopstick[(i + 1) % 5], chopstick[i]);  // 进餐完毕，释放哲学家占有的筷子
     		think();
     	}
     }
     ```

   - 方法三：规定奇数号哲学家先拿左筷子再拿右筷子，而偶数号哲学家相反

     原理：按照下图，将是 2,3 号哲学家竞争 3 号筷子，4,5 号哲学家竞争 5 号筷子。1 号哲学家不需要竞争。最后总会有一个哲学家能获得两支筷子而进餐。

     ![图示](C:/Users/lbj/Desktop/学习笔记/面试准备.assets/20161209141423404)

     ```java
     semaphore mutex[5] = {1,1,1,1,1}; 		//初始化信号量
     
     void philosopher(int i){
       while(true) {
         //thinking	
         if(i%2 == 1){                  // 奇数哲学家，先左再右
           wait(mutex[i]);              // 判断哲学家左边的筷子是否可用
           wati(mutex[(i + 1) % 5]);    // 判断哲学家右边的筷子是否可用
           eat();
           signal(mutex[(i + 1) % 5]);  // 释放右边的筷子
           signal(mutex[i]);            // 释放左边的筷子
         } else {                       // 偶数哲学家，先右再左
           wait(mutex[(i + 1) % 5]);    // 判断哲学家左边的筷子是否可用
           wati(mutex[i]);              // 判断哲学家右边的筷子是否可用
           eat();
           signal(mutex[i]);            // 释放左边的筷子
           signal(mutex[(i + 1) % 5]);  // 释放右边的筷子
         }
       }
     }
     ```

#### Q：**一个程序从开始运行到结束的完整过程（四个过程）** 

预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。 

编译：将预处理后的文件转换成汇编语言，生成.s文件 

汇编：汇编变为目标代码(机器代码)生成.o的文件 

链接：连接目标代码,生成可执行程序

#### Q：**操作系统的内存管理机制了解吗？内存管理有哪几种方式?**

简单分为**连续分配管理方式**和**非连续分配管理方式**这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 **块式管理** 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如**页式管理** 和 **段式管理**。

1. **块式管理** ：  远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
2. **页式管理** ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
3. **段式管理** ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。  段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段  MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。
4. **段页式管理机制** 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 **段页式管理机制** 中段与段之间以及段的内部的都是离散的。一般需要访问三次以上的内存：第一次是由段表地址寄存器得段表始址后访问段表，由此取出对应段的页表在内存中的地址。  第二次则是访问页表得到所要访问的物理地址。  第三次才能访问真正需要访问的物理单元。

#### Q：**虚拟内存**

很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。正是因为虚拟内存的存在，通过虚拟内存可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程独占一个4G空间）。这样会更加有效地管理内存并减少出错。

虚拟内存的意义是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间。

在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息

#### Q：**使用虚拟内存的好处**

- 扩大地址空间。每个进程独占一个4G空间，虽然真实物理内存没那么多。
- 内存保护：防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。
- 可以实现内存共享，方便进程通信。
- 可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续。

#### Q：**虚拟内存的实现方式**

1. 请求分页存储管理

   建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。

2. 请求分段存储管理

   建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段存储管理方式就如同请求分页存储管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调段功能装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间装入新的段。

3. 请求段页式存储管理

#### Q：**页面置换算法**

在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出外存。这时就用页面置换算法决定应该换哪个页面

- 最佳置换算法（OPT）

  每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面。该算法不可能被实现。

- 先进先出置换算法（FIFO）

  每次选择淘汰最早进入内存的页面。把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可

  但先进入的页面也有可能最经常被访问，所以这个算法性能差

- 最近最久未使用置换算法（LRU）

  每次淘汰的页面是最近最久未使用的页面。

  赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问依赖所经历的时间t。当需要淘汰一个页面时，选择现有页面中t值最大的

  实现困难，开销大

- 时钟置换算法（CLOCK），又称最近未用算法（NRU）

  为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，就将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描）

- 改进型的时钟置换算法

  简单的时钟置换算法仅考虑一个页面最近是否被访问过，还应考虑页面是否被修改过。因为如果被淘汰的页面没有被修改过，就不需要执行I/O操作将修改的内容写到磁盘上，否则就需要执行I/O操作写入到磁盘。故在其他条件都相同时，应优先淘汰没有修改过的页面

  设置一个修改位，修改位为0，表示没有被修改过；修改位为1，表示被修改过

  >算法规则：用（访问位，修改位）的形式表示各页面状态
  >
  >第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位
  >
  >第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮将所有扫描过的帧访问位设为0
  >
  >第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位
  >
  >第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换
  >
  >最多会进行四轮扫描

#### Q：**磁盘调度算法**

- 先来先服务（FCFS）

  根据进程请求访问磁盘的先后顺序进行调度

- 最短寻找时间优先（SSTF）

  优先处理与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总得寻道时间最短。可能产生饥饿现象

- 扫描算法（SCAN）

  只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动

- 循环扫描算法（C-SCAN）

  只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求

  对于各个位置磁道的响应频率很平均

- LOOK算法

  SCAN算法的改进。只要在磁头移动方向上不再有请求，就立即改变磁头方向

- C-LOOK算法

  C-SCAN算法的改进。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可

#### Q：**缓冲区的作用**

- 缓和CPU与I/O设备之间速度不匹配的矛盾

  CPU可以把要输出的数据快速地放入缓冲区，之后就可以做别的事。慢速的I/O设备可以慢慢从缓冲区取走数据

- 减少对CPU的中断频率。放宽对CPU中断相应时间的限制

- 解决数据粒度不匹配的问题

- 提高CPU与I/O设备之间的并行性

#### Q：**缓冲区算法**

- 单缓冲

  操作系统会在主存中为进程分配一个缓冲区

  当缓冲区数据非空时，不能往缓冲区写入数据，只能从缓冲区把数据读出；当缓冲区为空时，可以往缓冲区写入数据，但必须把缓冲区写满以后，才能从缓冲区把数据读出

- 双缓冲

  操作系统会在主存中为进程分配两个缓冲区，一个用来写，一个用来读

- 循环缓冲区

  将多个大小相等的缓冲区链接成一个循环队列

  使用双指针，in指针指向下一个可以写入数据的空缓冲区，out指针指向下一个可以取出数据的满缓冲区

- 缓冲池

  由系统中共用的缓冲区组成。这些缓冲区按使用状态可分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）

  另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区:用于收容输入数据的工作缓冲区(hin) 、用于提取输入数据的工作缓冲区(sin) 、用于收容输出数据的工作缓冲区(hout) 、用于提取输出数据的工作缓冲区(sout)

#### Q：**守护、僵尸、孤儿进程的概念**

守护进程：运行在后台的一种特殊进程，独立于控制终端并周期性地执行某些任务。

僵尸进程：一个进程 fork 子进程，子进程退出，而父进程没有wait/waitpid子进程，那么子进程的进程描述符仍保存在系统中，这样的进程称为僵尸进程。

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，这些子进程称为孤儿进程。（孤儿进程将由 init 进程收养并对它们完成状态收集工作）

## **数据库**

###   **数据库基本概念**

#### Q：**MySQL的架构**

- **连接层**：是一些客服端和连接服务，包括socket通信和大多数基于客户端/服务端工具实现的类似于TCP/IP 的通信，主要完成一些类似于连接处理、授权认证及相关安全的方案
- **服务层**：主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析以及优化部分内置函数的执行，所有跨存储引擎的功能也在这一层实现，如过程、函数等，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询的顺序是否利用索引，最后生成相应的执行操作
- **引擎层**：存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有功能不同
- **存储层**：主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互

#### Q：**S4QL语言的分类**

数据查询语言DQL：基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块

数据操作语言DML：插入、更新、删除

数据定义语言DDL：创建数据库中的各种对象-----表、视图、索引、同义词、聚簇等

数据控制语言DCL：用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等，如事务的**提交、回滚**

#### Q：**主键和外键的区别**

- 主键是能确定一条记录的唯一标识
- 外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性

#### Q：**三范式和反范式**

第一范式：每一字段（每一列）原子性不可再分

第二范式：任何一张表都应该有主键，所有非主键字段完全依赖主键，不能产生部分依赖

第三范式：所有非主键字段直接依赖主键，不能产生传递依赖

反范式化设计，意在用空间换时间，通过适当的冗余，提高查询效率

#### Q：**myisam 和 innodb的区别？**

- myisam引擎是5.1版本之前的默认引擎，支持全文检索、压缩，表锁定等，不支持事务、行级锁和外键，但每次查询都具有原子性，所以一般用于有大量查询少量插入的场景，存储表的总行数，索引和数据是分开存储的，存储文件有frm(表定义文件)、myd(数据文件)、myi(索引文件)
- innodb是基于聚簇索引建立的，支持事务、外键、行级锁，并且通过MVCC来支持高并发，不存储总行数，可以自动崩溃恢复，索引和数据存储在一起，存储文件有frm(表定义文件)、ibd(数据文件)

#### Q：**为什么 `select *` 效率低**

- 不需要的列会增加数据传输时间和网络开销

  - 用“SELECT * ”数据库需要解析更多的对象、字段、权限、属性等相关内容，会对数据库造成负担
  - 增大网络开销；* 有时会误带上如log、IconMD5之类的无用且大文本字段，数据传输size会几何增涨

- 对于无用的大字段，如varchar、text，会增加 IO 操作

  长度超过 728 字节的时候，会先把超出的数据序列化到另外一个地方，因此读取这条记录会增加一次 io 操作

- 失去MySQL优化器 ”覆盖索引“策略优化的可能性

  SELECT * 杜绝了覆盖索引的可能性，而基于MySQL优化器的“覆盖索引”策略又是速度极快，效率极高

### **事务特性与隔离级别**

- 一个事务是一个完整的业务逻辑单元，不可再分

- 事务的四大特性：ACID

  - A (atomicity)：**原子性**：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部成功，要么全部失败

    > 如何保证：通过undo log，undo log记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

  - C (consistency)：**一致性**：数据库总是从一个一致性的状态转换到另外一个一致性的状态。一致性保证只会有前状态和后状态，绝不会出现中间态。

    > 如何保证：通过undo log，回滚机制来保证

  - I (isolation)：**隔离性**：一个事务的执行不能被其他事务干扰。并发执行的各个事务之间不能相互干扰

    > 如何保证：通过给操作的对象加悲观锁或者乐观锁，MVCC(undo log)来保证

  - D (durability)：**持久性**：一旦事务提交，所做的修改就会永久保存到数据库中

    > 如何保证：通过redo log来保证的

- 有4个隔离级别

  - 读未提交：可能会读到其他事务未提交的数据，也叫做脏读
  - 读已提交（不可重复读 RC）：只会读取已经提交的事务，但存在**同一个事务里同一个查询读取到不同的结果**的情况（即同样的条件，你读取过的数据，再次读取出来发现值不一样了），这个也叫不可重复读
  - 可重复读(RR)：保证了在同一事务中多次读取同样记录的结果是一致的，但存在幻读，通过MVCC解决幻读（InnoDB默认）
  - 可串行化：给每一行读取的数据加锁，会导致大量超时和锁竞争的问题

```
Mysql官方给出的幻读解释是：只要在一个事务中，第二次select多出了row就算幻读。 
1.a事务先select，b事务insert确实会加一个gap锁，但是如果b事务commit，这个gap锁就会释放（释放后a事务可以随意dml操作）， 
2.a事务再select出来的结果在MVCC下还和第一次select一样， 
3.接着a事务不加条件地update，这个update会作用在所有行上（包括b事务新加的）， 
4.a事务再次select就会出现b事务中的新行，并且这个新行已经被update修改了

原因是前面的UPDATE语句执行之后，会将当前记录上存储的事务信息更新为当前的事务，而当前事务所做的任何更新，对本事务所有SELECT查询都变的可见，因此最后输出的结果是UPDATE执行后更新的所有记录。
```

#### Q：**隔离级别的实现原理**

- 读未提交
  - 事务对当前被读取的数据不加锁
  - 事务在更新数据时，必须先对其加 行级排他锁，直到事务结束才释放。
- 读已提交
  - 事务对当前被读取的数据使用MVCC机制，每次select时获取当前数据的最新快照，不加任何锁；
  - 事务在更新数据时，先对其加 行级排他锁，直到事务结束才释放。
- 可重复读
  - 事务对当前被读取的数据使用MVCC机制，**但与读已提交不同的是**，一次事务中只在第一次select时生成当前数据的快照版本，后续的查询都是在这个版本上进行；
  - 事务在更新数据时，先对其加 行级排他锁，直到事务结束才释放。
- 可串行化
  - 事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；
  - 事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。

#### Q：**快照读和当前读**

**快照读**：将历史数据存一份快照，其他事务增加与删除数据，对于当前事务来说是不可见的。

​	其实就是简单的select 操作。形如：select * from table where ?。

**当前读**：读取的是记录的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发修改这条记录。

​	其实就是特殊的读操作，比如插入、更新、删除属于当前读，需要加锁的也属于当前读。如下：

- select * from table where ? lock in share mode -- 共享锁 （这里可能不同版本的mysql对应命令不一样）
- select * from table where ? for update -- 排他锁
- insert into table values(?)
- update table set ? where ?
- delete from table where ?

“当前读”读取到的是数据库最新的数据，而“快照读”读取到的数据是事务中第一次建立ReadView时的数据+此事务中修改的数据。

#### Q：**什么是MVCC？InnoDB 的 MVCC 实现机制？MVCC 支持哪些事务隔离级别**

1. MVCC叫做多版本并发控制，实际上就是保存了数据在某个时间节点的快照。

2. InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，一个是行的创建时间系统版本号，另一个是行的过期(删除)时间系统版本号，每开始一个新的事务，版本号都会自动递增。事务开始时刻的系统版本号会作为该事务的版本号，用来和查询到的每行记录的版本号进行比较

   - **插入**数据（insert）:记录的创建版本号即当前事务的版本号

- 在**更新**操作的时候，采用的是先标记旧的那行记录为已删除，即删除版本号是当前事务版本号，然后插入一行新的记录，新纪录的创建版本号为当前事务版本号
  - **删除**操作的时候，就把当前事务版本号作为当前记录的删除版本号
- **查询**操作：在查询时要符合以下两个条件的记录才能被事务查询出来
  - 删除版本号 `未指定或者大于` 当前事务版本号，即查询事务开启后确保读取的行未被删除。(即事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)
  - 创建版本号 `小于或者等于` 当前事务版本号 ，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事务进行的insert。（即事务id为2的事务只能读取到create version<=2的已提交的事务的数据集）

3. MVCC只在读已提交和可重复读隔离级别下工作

#### Q：**mvcc机制并不能真正解决幻读，只解决了快照读下的幻读**

mvcc默认使用数据的创建时间和删除时间版本来管理数据，读的数据为快照，但写等操作是会在最新版本的数据上进行。存在以下几种情况：

- sessionA读，sessionB更新，sessionA读，无幻读 （默认使用A的版本快照）
- SessionA读，sessionB更新，sessionA更新，sessionA的预期结果与实际得到的结果不一致。（A更新时使用最新数据，更新完以后将版本修改为当前版本）
- 如果其他session删除数据，当前session更新时找不到数据，但是此时读取仍然能读取到。（当前session版本快照还未被删除）

#### Q：**如何解决幻读**

在快照读读情况下，mysql通过mvcc来避免幻读。

当前读读情况下，mysql通过 行记录锁+间隙锁 来避免幻读。

select * from t where a=1;属于快照读

select * from t where a=1 lock in share mode;属于当前读

#### Q：**为什么要用int型自增id,用string不行么?**

1. int 使用更少的存储空间，而且数据类型简单，可以节约CPU的开销，更便于表结构的维护
2. 默认都会在主键上建立主键索引，而插入速度严重依赖于插入顺序，按照主键的**顺序插入**是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个**自增的ID列为主键**
3. 对于InnoDB存储引擎而言，每个二级索引都会使用主键作为索引值的后缀，使用自增主键可以减少索引的长度（大小），方便更多的索引数据载入内存
4. 可以使索引数据更加紧凑，在数据插入、删除、更新时可以做到索引数据尽可能少的移动、分裂页，减少碎片的产生，减少维护开销
5. 在数据插入时，可以保证逻辑相邻的元素物理也相邻，便于范围查找

#### Q：**SQL语句执行加载顺序**

from、on、join、where、group by、having、select、distinct（去重）、order by、limit

### **索引**

#### Q：**索引是什么？**

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是**索引**。

一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上

索引按照数据结构来说主要包含**B+树**和**Hash索引**。

#### Q：**索引的查找时间复杂度**

- hash索引：O(1)
- B+树索引：O(logn)

#### Q：**索引的种类**

- 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引

- 唯一索引：不允许其中任何两行具有相同索引值的索引，但可以为null

- 主键索引：设定为主键后数据库会自动建立索引，不允许为null

- 联合索引：多列值组成一个索引，专门用于组合搜索

  同样是B+树的结构，只不过它的 **data部分** 存储的是联合索引所在行记录的主键值

  对于联合索引来说只不过比单值索引多了几列，而这些索引列全都出现在索引树上。对于联合索引，存储引擎会首先根据第一个索引列排序，如上图我们可以单看第一个索引列，如，1 1 5 12 13…它是单调递增的；如果第一列相等则再根据第二列排序，依次类推就构成了索引树

- 全文索引：对文本的内容进行分词，进行搜索

- 覆盖索引：一个索引包含所有需要查询的字段的值

#### Q：**hash索引**

hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行 回表查询获得实际数据。hash索引进行等值查询更快(一般情况下)，无法进行范围查询

#### Q：**B+树的原理**

B树：**有序数组+平衡多叉树**，关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据，搜索有可能在非叶子结点结束

B+树：**有序数组链表+平衡多叉树**，所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的，增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层

#### Q：**为什么不用hash索引，而用B+树索引**

- hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询
- hash索引不支持使用索引进行排序
- hash索引不支持模糊查询以及多列索引的最左前缀匹配
- hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差

#### Q：**为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？**

- B+树的磁盘读写代价更低
  - B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点 的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了
- B+树的查询效率更加稳定
  - 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当

#### Q：**通常一棵B+树可以存放多少行数据？**

这里先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。

单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。

那么现在我们需要计算出`非叶子节点能存放多少指针`，其实这也很好算，我们假设`主键ID为bigint类型，长度为8字节`，而`指针大小`在InnoDB源码中设置为`6字节`，这样一共14字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即`16384/14=1170`。那么可以算出一棵`高度为2的B+树`，能存放`1170*16=18720条`这样的数据记录。

根据同样的原理我们可以算出一个`高度为3的B+树`可以存放：`1170*1170*16=21902400条`这样的记录。所以在InnoDB中`B+树高度一般为1-3层`，它就能满足千万级的数据存储。在查找数据时 **一次页的查找代表一次IO**， 所以通过主键索引查询通常 **`只需要1-3次IO操作`** 即可查找到数据。

#### Q：**MyISAM和InnoDB两个存储引擎的索引实现方式**

**MyISAM索引实现**：MyISAM首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址，故也称**非聚簇索引**。

**InnoDB索引实现：**在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这种索引叫做**聚簇索引**。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

#### Q：**InnoDB主键索引跟非主键索引在数据存储上的差异** 

主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引 （clustered index）。 

非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引 （secondary index）。

#### Q：**使用聚簇索引的优势**

1. 由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中（缓存器），**再次访问时，会在内存中完成访问，不必访问磁盘**。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。

2. 非聚簇索引的叶子节点，存储主键值，而不是数据的存放地址，**不在内存中，要去磁盘读取**。当行数据发生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。

   **注：**我们知道一次io读写，可以获取到16K大小的资源，我们称之为读取到的数据区域为Page。而我们的B树，B+树的索引结构，叶子节点上存放好多个关键字（索引值）和对应的数据，都会在一次IO操作中被读取到缓存中，所以在访问同一个页中的不同记录时，会在内存里操作，而不用再次进行IO操作了。除非发生了页的分裂，即要查询的行数据不在上次IO操作的缓存里，才会触发新的IO操作。

3. 因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。**（强烈的对比）**

4. 不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。

#### Q：**最左前缀原则**

指的是查询从索引的**最左前列开始并且不跳过索引中的列**

MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。

Q：**为什么是最左前缀原则，而不是最右或者中间原则？**

#### Q：**索引的适用场景**

适用场景：主键自动建立唯一索引、频繁作为**查询条件**的字段应该创建索引、查询中与其它表关联的字段，**外键关系**建立索引、单键/组合索引的选择问题，**组合索引性价比更高**、查询中**排序的字段**，排序字段若通过索引去访问将大大提高排序速度、查询中**统计**或者**分组**字段

不适用场景：表**记录太少**（有无索引差别不大）、经常**增删改**的表或者字段、Where 条件里用不到的字段不创建索引、**过滤性不好**的不适合建索引（重复性较高，比如国籍、性别之类的字段）

#### Q：**有了解过“回表”的概念吗？什么情况下会出现“回表”？**

回表就是先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据， 即基于非主键索引的查询需要多扫描一棵索引树。 当查询的字段在二级索引上没有的时候，就需要“回表”在主键索引上再查一次。

#### Q：**什么情况下会发生索引失效**

- **不遵守最左前缀原则**。对于复合索引，查询字段与索引字段顺序的不同会导致索引无法充分使用，甚至索引失效，即如果不使用前列，后续列也将无法使用
- **若在索引列上做任何操作**（计算、函数、(自动 or 手动)类型转换），可能会导致索引失效而转向全表扫描
- 对某一索引**使用范围查询**后，该范围后的索引全部失效了
- 在使用**不等于(!= 或者<>)时**，有时会无法使用索引而导致全表扫描
- 对索引使用**模糊查询时，以%开头**造成索引失效。只有当百分号在右边、索引为单值索引且模糊查询语句在最右边时，索引才会生效，其他情况均失效了
- 如果**使用or**，可能导致索引失效。所以要减少or的使用，可以使用 union all 或者 union 来替代

#### Q：**优化关联查询**

- 小表驱动大表，即小的数据集驱动大的数据集

- 尽量在被驱动表、大表上建立索引

#### Q：**在排序时使用索引进行优化**

- 使用覆盖索引

- ORDER BY 后面字段的顺序要和复合索引的**顺序完全一致**
- ORDER BY 后面的索引必须按照顺序出现，**排在后面的可以不出现**
- 要进行升序或者降序时，**字段的排序顺序必须一致**。不能一部分升序，一部分降序，可以都升序或者都降序
- 如果复合索引前面的**字段作为常量**出现在查询条件中，**排序字段可以为紧跟其后的字段**

#### Q：**慢查询优化**

1. 查看是否使用索引，索引是否失效

2. 优化数据库结构

   将字段很多的表分解成多个表：对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表

   增加中间表：对于需要经常联合查询的表，可以建立中间表以提高查询效率

3. 分解关联查询： 可以将一个大的查询分解为多个小查询

4. 优化limit分页

### **日志**

#### Q：**mysql三大日志——binlog、redo log 和 undo log**

- binlog： 用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。`binlog` 是 `mysql`的逻辑日志，并且由 `Server` 层进行记录。

- redo log：保证事务的持久性，只记录事务对数据页做了哪些修改

  mysql每执行一条 DML语句，先将记录写入 redo log buffer，后续某个时间点再一次性将多个操作记录写到 redo log file持久化到磁盘。如果发生宕机，则读取磁盘上的 redo log file 进行数据的恢复。从这个角度来说，**MySQL 事务的持久性是通过 redo log 来实现的**。

- undo log：实现事务回滚

  在事务操作之前,把需要操作的数据备份到undo log中，用于实现事务的回滚

#### Q：**binlog日志**

二进制日志文件Binlog格式有以下3种：

- Statement：基于SQL语句级别的Binlog，每条修改数据的SQL都会保存到Binlog里
- Row：基于行级别，记录每一行数据的变化，也就是将每行数据的变化都记录到Binlog里面，记录得非常详细，但是并不记录原始SQL；在复制的时候，并不会因为存储过程或触发器造成主从库数据不一致的问题，但是记录的日志量较Statement格式要大得多。
- Mixed：混合Statement和Row模式，默认情况下采用Statement模式记录，某些情况下会切换到Row模式，例如SQL中包含与时间、用户相关的函数等。

#### Q：**bin log跟redo log区别**

- redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。
- redo log是物理日志，记录的是在某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如给ID=2这一行的c字段加1。
- redo log是循环写的，空间固定会用完；binlog是可以追加写入的。追加写是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

### **锁机制**

#### Q：**MySQL支持哪三种锁**

- 页级锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
- 表锁：锁定整个表，开销最小，但是也阻塞了整个表。开销小，加锁快，不会出现死锁。
- 行锁：即只允许事务读一行数据。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。开销大，加锁慢，会出现死锁。

#### Q：**悲观锁与乐观锁**

- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。 悲观锁是数据库层面加锁，都会阻塞去等待锁。
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样则更新，反之则拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。 缺点：并发很高的时候，多了很多无用的重试。乐观锁，不能解决脏读的问题。

#### Q：**表锁有哪些？**

- 若一个用户正在执行写操作，会获取排他的“写锁”，这可能会锁定整个表，阻塞其他用户的读、写操作；
- 若一个用户正在执行读操作，会先获取共享锁“读锁”，这个锁允许其他读锁并发的对这个表进行读取，互不干扰。只要没有写锁的进入，读锁可以是并发读取统一资源的。

#### Q：**行锁有哪些？**

- 共享锁（读锁、S锁）：其他事务可以读，但不能写。也就是多个事务只能读数据不能改数据。
- 排他锁（写锁、X锁） ：一个事务在一行数据加上排他锁后，其他事务不能在其上加其他的锁。也就是其他事务既不能读，也不能写。

#### Q：**InnoDB的意向锁**

为了支持在不同粒度上进行加锁操作(允许行锁和表锁共存，实现多粒度锁机制)，InnoDB 还有两种内部使用的意向锁（Intention Locks），是用来表达一个事务想要获取什么，这两种意向锁都是表锁，意向锁之间相互兼容：

- 意向共享锁（IS- intent share lock）事务想要获得一张表中某几行的共享锁。事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
- 意向排他锁（IX -intent exclusive lock）事务想要获得一张表中某几行的排他锁。事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

**IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突**

当有一个表的写锁申请时。如果没有意向锁的话，则需要遍历整个表判断是否有行锁的存在，以免发生冲突
如果有了意向锁，只需要判断该意向锁与即将添加的表级锁是否兼容即可。**因为意向锁的存在代表了，有行级锁的存在或者即将有行级锁的存在**。因而无需遍历整个表，即可获取结果

#### Q：**行锁升级成表锁**

索引失效，就会变成全表扫描查询，就会导致**行锁变表锁**

#### Q：**行锁的几种算法**

- Record Lock **记录锁**：事务加锁后锁住的只是表的某一条记录。

  加了记录锁之后可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。

- Gap Lock **间隙锁**：锁定一个范围，但不包含记录本身

  当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。可以防止幻读

- Next-Key Lock **临键锁**：记录锁+ 间隙锁，锁定一个范围，包含记录本身

  临键锁是InnoDB的行锁默认算法，它是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。

#### Q：**死锁的产生**

两个(或以上的)事务对相同的资源的加锁顺序不一致。

- 一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A
- 用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A 有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升到独占锁也就不可能释放共享锁，于是出现了死锁。
- 如果在事务中执行了一条不满足条件的update语句，则执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。

#### Q：**如何解决死锁**

- 一种策略是，直接进入等待，直到超时。
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。

#### Q：**如何避免死锁**

1. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

### 主从复制

#### Q：**主从复制原理**

将主数据库中的DDL（数据定义语言）和DML（数据操作语言）操作通过二进制日志传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。

复制三步骤：

1. 在主库上记录二进制日志（binary log），首先主库要开启binlog日志记录功能，并授权Slave从库可以访问的权限。这里需要注意的一点就是binlog的日志里的顺序是按照事务提交的顺序来记录的而非每条语句的执行顺序。

2. 从库将binLog复制到其本地的RelayLog（中继日志）中

   首先从库会启动一个工作线程，称为I/O线程，I/O线程跟主库建立一个普通的客户端连接，然后主库上启动一个特殊的二进制转储（binlog dump）线程，此转储线程会读取binlog中的事件。当追赶上主库后，会进行休眠，直到主库通知有新的更新语句时才继续被唤醒。

3. slave重做中继日志中的事件，从relay log里面读取内容，从**Exec_Master_Log_Pos**位置开始执行读取到的更新事件，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的

主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

- **binlog 线程** ：负责将主服务器上的数据更改**写入二进制日志**（Binary log）中。
- **I/O 线程** ：负责从主服务器上读取二进制日志，并**写入从服务器的中继日志**（Relay log）。
- **SQL 线程** ：负责**读取中继日志**，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

#### Q：**异步复制、全同步复制和半同步复制**

- 异步复制：主库在执行完客户端提交的事务后，只要将执行逻辑写入到binlog后，就立即返回给客户端，并不关心从库是否执行成功，这样就会有一个隐患，就是在主库执行的binlog还没同步到从库时，主库挂了，这个时候从库就就会被强行提升为主库，这个时候就有可能造成数据丢失。

- 全同步复制：主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。

- 半同步复制：主库在执行完客户端提交的事务后，要等待至少一个从库接收到binlog并将数据写入到relay log中才返回给客户端成功结果。半同步复制模式，比异步模式提高了数据的可用性，但是也产生了一定的性能延迟

  主要原理是，在master的dump线程去通知从库时，增加了一个ACK机制，也就是会确认从库是否收到事务的标志码，master的dump线程不但要发送binlog到从库，还有负责接收slave的ACK。当出现异常时，Slave没有ACK事务，那么将自动降级为异步复制，直到异常修复后再自动变为半同步复制

#### Q：**半同步复制的隐患和解决方案**

半同步复制模式也存在一定的数据风险，当事务在主库提交完后等待从库ACK的过程中，如果Master宕机了，这个时候就会有两种情况的问题。

- **事务还没发送到Slave上**：若事务还没发送Slave上，客户端在收到失败结果后，会重新提交事务，因为重新提交的事务是在新的Master上执行的，所以会执行成功，后面若是之前的Master恢复后，会以Slave的身份加入到集群中，这个时候，之前的事务就会被执行两次，第一次是之前此台机器作为Master的时候执行的，第二次是做为Slave后从主库中同步过来的。
- **事务已经同步到Slave上**：因为事务已经同步到Slave了，所以当客户端收到失败结果后，再次提交事务，你那么此事务就会再当前Slave机器上执行两次。

为了解决上面的隐患，MySQL从5.7版本开始，增加了一种新的半同步方式。新的半同步方式的执行过程是将主库的提交事务这一步移动到了等待从库接收binlog后面。这样保证了**只有Slave的事务执行完返回ACK后，才提交主库事务**。

> 但存在问题：若是当主库等待Slave同步成功的过程中Master挂了，这个Master事务提交就失败了，客户端也收到了事务执行失败的结果了，但是Slave上已经将binLog的内容写到Relay Log里了，这个时候，Slave数据就会多了

#### Q：**主从复制的好处**

1. 实现服务器负载均衡
2. 通过复制实现数据的异地备份
3. 提高数据库系统的可用性

#### Q：**读写分离能提高性能的原因**

主服务器处理 写操作 以及 实时性要求比较高的读操作，而从服务器处理读操作

- 主从服务器负责各自的读和写，极大程度**缓解了锁的争用**
- **从服务器**可以使用MyISAM，提升查询性能以及节约系统开销
- 增加冗余，提高可用性

### **SQL和NoSQL**

#### Q：**MongoDB和MySQL的区别**

- MongoDB是非关系型数据库，数据是基于键值对的形式存储的，类似于JSON对象，数据没有耦合，容易扩展，丰富的查询功能，无需经过sql层的解析，内存级别的查询，读写性能高，不支持ACID事务特性
- MySQL是关系型数据库，具有固定的表结构，支持SQL，可用于复杂的查询，支持事务

#### Q：**如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？**

GridFS是一种将大型文件存储在MongoDB中的文件规范。使用GridFS可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了BSON对象有限制的问题。

#### Q：**常见的NoSQL及其特点**

1. Redis

   基于key-value存储格式，支持多种数据结构，支持持久化操作，支持分布式，操作具有原子性，支持简单的事务，存取高效。但由于只能使用单线程，性能受限于CPU。主要用于数据量较小的更性能操作和运算上。

2. Memcache

   利用多核优势，单实例吞吐量极高。但只支持简单的key-value数据结构，不像Redis可以支持丰富的数据类型，也无法进行持久化，数据不能备份，无法进行数据同步

3. MongoDB

   数据是基于键值对的形式存储的，类似于JSON对象，支持丰富的数据表达、索引，数据没有耦合，容易扩展，无需经过sql层的解析，内存级别的查询，读写性能高，不支持ACID事务特性。主要解决海量数据的访问效率问题，单个文件大小限制16M

## **论文**

​	**基于节点信任度的 LEO（低轨道）卫星网络安全路由算法**

​	主要是针对 LEO 卫星通信网络内部攻击构建的信任评估模型，和以评估模型为基础的可靠路由算法的研究设计。网络攻击分类按照恶意节点和 LEO 卫星网络的关系划分，分为外部攻击和内部攻击。（外部是。。。内部是。。。）。信任评估模型包括直接信任、间接信任和聚合信任。安全路由算法包括基础路由模块、动态信任评估处理模块和动态健康诊断处理模块。

​	LEO卫星通信系统优势：通信时延小、覆盖范围广、发射成本低等，是作为未来 6G 通信时代发展的重要一员。暴露在复杂空间环境中的 LEO 卫星的 ISL（星间链路），由于自身稳定性差，开放性、暴露性等特点的影响。容易受到来自恶意节点的干扰和攻击，而卫星网络的路由协议是诸多攻击行为的首选目标，使得空间中的数据传输面临极大的安全威胁和挑战。攻击分类按照恶意节点和 LEO 卫星网络的关系划分，分为外部攻击和内部攻击。

​	**外部攻击**是指网络外部的恶意节点，对卫星网络内部的节点进行窃听和压制等行为的攻击。用传统的基于密码学的安全技术可以有效解决。**内部攻击**是指卫星网络中的正常节点被恶意节点劫持并篡改，从而以合法身份重新入网。在卫星网络内部发动像黑洞、灰洞等攻击方式。==黑洞攻击==：完全丢弃收到的全部数据包，==灰洞攻击==：只会丢弃收到的部分数据包。这种内部的攻击方式，基于密码学的安全技术无法继续保障路由安全性，但是信任管理对于解决网络内部攻击表现出色。

​	**文章贡献**：首先基于 D-S 证据理论，设计了一套不需要任何集中式或分布式可信基础措施，通过卫星节点的分布式协作，就可实现节点信任度更新的 LEO 卫星网络动态信任评估模型。包括直接信任、间接信任和聚合信任模型。之后采用这套信任评估模型，对一种低开销基于轨道预测的 LEO 卫星网络路由协议进行安全信任加固改造，设计出 STL 安全路由算法，以增强空间数据传输的安全性和可靠性。包括三个模块，基础路由模块、动态信任评估处理模块和动态健康诊断处理模块。

​		==直接信任模型==：若一个卫星节点与其他卫星节点正常交互次数越多，则表明该卫星节点的可信程度越高，其发生恶意行为的可能性越低。因此，本文根据一个卫星节点是否能正确转发数据包，来评价该节点的可靠性程度。卫星节点可以根据之前在本地监测、收集存储的直接交互行为历史，来计算对其他卫星节点的直接信任。==间接信任模型==：在 LEO 卫星通信系统中，若卫星节点 i 对于邻居转发卫星节点 j 的直接信任不够充分时，此时就需将间接信任纳入信任评估的考虑因素中，既而求得卫星节点 i 对于邻居转发卫星节点 j 的聚合信任，以此来最终判定节点 j 是否可信。==聚合信任模型==：通过卫星网络的直接信任与间接信任模型的处理，便可得到修正处理后的直接信任 SD'i,j 与间接信任 SI'i,j。然后卫星节点 i 采用Dempster 合成法则对 SD'i,j和 SI'i,j 进行合成，最终求得卫星节点 i 对邻居转发卫星节点 j 的聚合信任值 SCi,j。

​	**STL 安全路由算法**

应用于卫星网络的信任路由方案多是以下两种形式：

1. 将地面网络中的信任路由方案改造迁移至卫星网络。此类信任路由方案多是以地面传统移动 ad hoc 网络路由协议（如 DSR、AODV 等），作为原料路由协议，然后与信任评估模型相融合得到的卫星网络信任路由方案[54]。虽然 LEO 卫星网络是一种特殊的、具有规律运动特点的空间移动 ad hoc 网络。但是，直接采用地面移动 ad hoc 网络的路由协议，作为信任改造所使用的原料路由协议的话，对于解决卫星网络内部路由攻击问题不具有针对性与特定性。例如以 AODV 协议作为原料路由协议，进行信任改造所得到的安全路由。其在实际运行寻找可行路径的时候，会在卫星全网范围内洪泛 RREQ 路由请求包，极大地消耗了卫星网络有限的带宽资源。且星间链路传播时延也较长，拓扑变化也较为剧烈。因此，RREP所回复的路由转发路径也可能已过时、失效，不能较好地适应卫星网络的内在运动特点，也就大大降低了此类信任路由所带来的有益安全防护效果。

1. 采用跨层卫星协作的方式实现信任安全路由。如采用 MEO 卫星与 LEO卫星相配合的方式[55-56]。首先，MEO 卫星对 LEO 卫星实施分组管理。同时，设定MEO 卫星只具有路由管理功能且假定为绝对可信的，LEO 卫星节点只负责数据的路由转发。然后，MEO 卫星负责收集和统计 LEO 卫星节点的路由行为，并结合相应信任评估模型，识别和隔离恶意 LEO 卫星节点，完成相应安全式路由表的计算与下发。最后，LEO 卫星节点就可依据路由表实现数据的安全传输。但此方案实现难度较大，MEO 卫星与 LEO 卫星之间的相对运动剧烈，卫星间协作难度较大，且假设 MEO 卫星为绝对可信也不太合理，故此方案也不可取。

​	本文将一种基于轨道预测的低开销 LEO 卫星路由协议 OPSPF 作为原料路由协议，进行信任安全加固改造。OPSPF 路由协议是假设系统运行于安全环境中的，网络中的每颗卫星也都是绝对可信，并没有针对路由攻击提供可靠的安全防护措施。一旦网络中存在恶意节点并发起如黑洞、灰洞等攻击行为，就会造成较为严重的网络故障，甚至系统瘫痪。

​	SLT安全路由算法各部分

1. （1）基础路由模块：SLT 算法核心组成部分，通过输入卫星位置信息、全网端口风险标识以及全网端口健康标识等参数参与运算。既处理 LEO 卫星网络中的规律性事件（规律性拓扑变化），亦同时融合处理非规律事件（动态信任评估处理模块提供恶意卫星节点信息、动态健康诊断处理模块提供非规律拓扑变化信息），实现对链路状态数据库（Link State Data Base, LSDB）、路由表以及本地端口状态标识的更新。==此模块由卫星节点同步周期性调用（实现路由表周期性更新）与由动态信任评估处理模块与动态健康诊断处理模块异步触发调用（实现路由表==
   ==触发式更新）。维护得到安全式无失效无故障链路路由表，用以指导数据包转发。==
2. （2）动态信任评估处理模块：通过基于 D-S 证据理论的 LEO 卫星网络信任评估模型，对 LEO 卫星网络中的每颗卫星实施周期性分布式动态信任评估。及时检测并处置恶意卫星节点，实现对全网端口风险标识的更新。并异步调用基础路由模块，实现对恶意卫星节点的隔离，防止恶意卫星节点加入路由转发路径。
3. （3）动态健康诊断处理模块：通过 Hello 报文的动态探测，实现对 ISL 的周期性检测，及时捕获发现 LEO 卫星网络的不规律拓扑变化，如突发性 ISL 故障、故障 ISL 恢复等。实现对全网端口健康标识的更新，并异步调用基础路由模块，实现发生 ISL 故障或故障 ISL 恢复时的路由重构。

# Java基础



## 对Java平台的理解



* 基本的语言特性：面向对象、反射、泛型

  * Java类库：核心类库（IO/NIO（读写文件的类）、网络（socket等）、utils（包含大量集合类、工具类）、lang核心包（String、System等）

  * Java虚拟机（垃圾收集器、动态编译）

  * 与其他语言最大不同相比有两大特性：跨平台性和自动垃圾回收

    

## 对Java面向对象的理解

* 面向对象是一种比较符合人类思维的编程思想。Java将世间万物都视为对象，每个对象都有其对应的属性、功能，然后使用对象来映射现实中的事物，利用对象之间的关系用来描述事物之间的联系。
  * 面向对象有三大特性：
    * 封装：将对象的属性和行为封装起来，不需要让外界知道具体实现细节，这就是封装思想。例如，用户使用电脑，只需要使用手指敲键盘就可以了无须知道电脑内部是如何工作的，即使用户可能碰巧知道电脑的工作原理，但在使用时，并不完全依赖电脑工作原理这些细节。
    * 继承性主要描述的是类与类之间的关系，通过继承，可以在无须重新编写原有类的情况下，对原有类的功能进行扩展。比如说，男人和女人，都具有人的特点，所以他们可以继承人这个类，但是他们又具有区别，所以继承人这个类之后，在男人类或者女人类之中单独添加对应特性的方法和属性就可以了。继承性不仅增强了代码复用性，提高了开发效率，而且为程序的修改补充提供了便利。
    * 多态性：多态性指的是在程序中允许出现重名现象，它指在一个类中定义的属性和方法被其他类继承后，它们可以具有不同的数据类型或表现出不同的行为，这使得同一个属性和方法在不同的类中具有不同的语义。产生的条件是继承和重载。继承是指子类继承父类时，有方法的重写或者在方法的调用中，有指向子类的父类的引用；重载是相同方法名，但是参数不同。

Q：**面向对象与面向过程的区别**

- 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了，性能高

- 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为，易维护、易复用、易扩展。有三大特性。

  继承是子类继承了父类的属性和方法，私有属性子类是继承拥有的，只不过子类并不能访问父类的私有属性，子类可以对父类的属性覆盖，对方法进行重写。 

  封装就类似与U盘的使用，所有的内部逻辑是不需要我们知道的，唯一给我们使用的就是方法的接口，传入参数来使用封装的东西。 

  多态分为编译时多态和运行时多态，编译时多态就是重载，方法名字相同，但参数的类型，顺序和数量不同，程序在编译时就可以确定要执行哪个方法。 

Q：**多态**

就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

Q：**重写和重载的区别**

- **重载**（Overload）是让类以统一的方式处理不同类型数据的一种手段，调用方法时通过传递**不同参数个数和参数类型**来决定具体使用哪个方法的多态性，编译时多态
- **重写**（Override）是父类与子类之间的多态性，实质是对父类的函数进行重新定义，运行时多态

## Java IO

Q：**什么是IO**

- 从计算机结构的视角来看， I/O 描述了计算机系统与外部设备之间通信的过程。

  输入设备向计算机输入数据，输出设备接收计算机输出的数据。

- 从应用程序的视角来看，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。

  当应用程序发起 I/O 调用后，会经历两个步骤：

  1. 内核等待 I/O 设备准备好数据
  2. 内核将数据从内核空间拷贝到用户空间。



Q：**同步与异步**

- **同步：** 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。
- **异步：** 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。

同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。



Q：**阻塞和非阻塞**

- **阻塞：** 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。
- **非阻塞：** 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。



Q：**常见的IO模型**

同步阻塞 I/O**、**同步非阻塞 I/O**、**I/O 多路复用**、**信号驱动 I/O 和异步 I/O



Q：**BIO (Blocking I/O)**

同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。

在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。



Q：**NIO (Non-Blocking IO)**

NIO是一种同步非阻塞的I/O模型。它支持面向缓冲的，基于通道的I/O操作方法。提供了 Channel , Selector，Buffer等抽象，通道负责传输，缓冲区负责存储

Java NIO系统的核心在于：**通道(Channel)和缓冲区(Buffer)**。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于**连接 IO 设备的通道**以及用于**容纳数据的缓冲区**。然后操作缓冲区，对数据进行处理，并使用连接器selector处理socket连接



Q：**AIO（Asynchronous I/O）**

它是异步 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。



## 其他问题

Q：**JVM vs JDK vs JRE**

- JVM：运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。
- JRE：Java 运行时环境。也就是我们说的JAVA平台，所有的Java程序都要在JRE下才能运行，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。与JDK相比，它不包含开发工具——编译器、调试器和其它工具。
- JDK：Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。

如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。



Q：**什么是字节码?采用字节码的好处是什么?**

在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 `.class`  的文件），它不面向任何特定的处理器，只面向虚拟机。Java  语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java  程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。



Q：**基本数据类型的大小**

byte——1字节、short——2字节、int——4字节、long——8字节

float——4字节、double——8字节、boolean——1字节、char——2字节



Q：**public,default,protected,private区别**

- public：可以被任何地方的类访问
- protected：可以被类内部访问，也可以被同个包下的类访问到，还可以被子类访问到
- default：只能被类内部和同个包下的类访问到
- private：只能在本类内部访问到

Q：**==和equals的区别**

- 对于 ==，比较的是值是否相等 
  - 如果作用于基本数据类型的变量，则直接比较其存储的 “值” 是否相等；
  - 如果作用于引用类型的变量，则比较的是所指向的对象的地址
- 对于equals方法，注意：equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象
  - 如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；
  - 诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。



Q：**split()和join()的区别**

- Array.join() 把数组中的所有元素放入一个字符串，元素是通过指定的分隔符进行分隔的

- String.split() 获取一个字符串，然后在分隔符处将其断开，从而返回一批字符串。 

这两个函数之间的区别在于join可以使用任何分割字符串将多个字符串连接起来，而split()只能使用一个字符分隔符将字符串断开。 join和split互为逆操作



Q：**final finally finalize的区别** 

final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。

finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。

finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。



Q：**Java里的接口和抽象类的区别**

- 接口和抽象类都不能被实例化
- 抽象类除了不能被实例化，可能含有抽象方法外，其他的都和普通方法一样
- 抽象类只能单继承，接口可以实现多个父接口
- 抽象类可以存在普通成员变量，接口只能存在public static final的变量，必须初始化
- 接口不能包含构造器，抽象类可以包含**构造器**，抽象类里的构造器并不是用于创建对象，而是**让其子类调用这些构造器**来完成属于**抽象类的初始化操作**。
- 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用



Q：**什么是包装类？用途？**

- Java是一个面向对象的编程语言，但是Java中的八种基本数据类型却是不面向对象的，为了使用方便和解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八种基本数据类型对应的类统称为包装类(Wrapper Class)，包装类均位于java.lang包。
- 作为 和基本数据类型对应的类 类型存在，方便涉及到对象的操作。包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。



Q：**自动装箱/拆箱**

装箱就是自动将基本数据类型转换为包装类类型；拆箱就是自动将包装类类型转换为基本数据类型。装箱操作会创建对象，频繁的装箱操作会消耗许多内存，影响性能，所以可以避免装箱的时候应该尽量避免。

```Java
   Integer num = 99; //赋给的是基本数据类型，但是底层相当于执行了 Integer num = Integer.valueOf(99);
```

```Java
   int total = num; //赋给的是包装类类型，自动转换为基本数据类型，自动执行 int total = num.intValue();
```

 装箱的过程会创建相应的对象，会消耗内存，影响性能。

自动装箱会先判断传入i的大小，如果

 \* i >= 128 || i < -128 =====> new Integer(i) 
 \* i < 128 && i >= -128 =====> SMALL_VALUES[i + 128]，i在范围内，直接返回在缓存中已经创建好的对象，所以此去区间的Integer对象可以用==进行判断。所以整型包装类之间的比较，推荐用equals方法。



### String



Q：**java 中操作字符串都有哪些类？它们之间有什么区别？**

- 操作字符串的类有：String、StringBuffer、StringBuilder。
- String 和 StringBuffer、StringBuilder 的区别在于 **String 声明的是不可变的对象，每次操作都会生成新的 String  对象**，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，StringBuffer容量扩为**原大小的2倍+2**（加2是因为拼接字符串通常末尾都会有个多余的字符）
- String在Java9以前字符串采用char[]数组来保存字符，因此字符串的每个字符占2字节；而Java9的字符串采用byte[]数组再加一个编码标志（LATIN1、UTF16）字段来保存字符，因此字符串的每个字符只占1字节
- StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，StringBuffer类中的方法都添加了**synchronized关键字**，所以StringBuilder 的性能要远大于 StringBuffer。
- 另一个区别是在调用toString方法时，StringBuffer会使用缓冲区的toStringCache数组来构造一个字符串，而StringBuilder则需要复制一次字符数组，再构造一个字符串



Q：**为什么String声明的是不可变对象？**

1. 从源码上来看，字符串采用char[]数组保存字符，而这个char[]数组采用了private和final修饰，因为数组一旦创建，长度不可变。并且被final修饰的引用一旦指向某个对象之后，不可再指向其他对象，所以String不可变
2. 从节省内存角度上看。字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串引用都指向池中的同一个字符串，只有当字符串是不可变的，字符串池才有可能实现。而且hashmap中的key大多是String类型的，设置为不可变就可以将其hashcode缓存起来，下次查询的时候就不需要重新计算了。
3. 从安全的角度上来看。用户名、密码等隐私数据都是用字符串传递的，如果字符串可变的话会引起安全问题。



Q：**String str="i"与 String str=new String("i")一样吗？**

不一样，因为内存的分配方式不一样。String str="i"是直接赋值的方式，java 虚拟机会将其分配到常量池中，在栈中创建该字符串的引用并指向它；而 String str=new String("i") 会先查找字符串常量池，如果存在该字符串。则会在堆内存中创建一个对象指向该字符串，在栈中创建该对象的引用，并指向该对象，会创建两个对象。



### 泛型

Q：**什么是泛型**

集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。

泛型定义在：自定义泛型类、自定义泛型接口、自定义泛型方法



Q：**使用泛型有何优点**

使用泛型的主要优点是能够在编译时而不是在运行时检测错误 ！！！1.5之前用Object来接收，读取出来需要强转，容易发生类型转换异常；

能够使代码可读性更高；

与普通的 Object 代替一切类型这样简单粗暴而言，泛型使得数据的类别可以像参数一样由外部传递进来。它提供了一种扩展能力。它更符合面向抽象开发的软件编程宗旨。



Q：**泛型擦除**

泛型其实是一种语法糖，**在JVM层面是没有泛型概念的**。编译器在编译的时候，会对泛型进行擦除为Object，并相应的做一些类型转换动作。转换动作为泛型翻译，即编译器会将使用了泛型的实例标记，每次调用前进行检查，非指定类型的方法都不能调用成功。

 有一种情况不会擦除为Object，比如类型限定的语法中，类型参数会被转译为上界，构建的时候无论限定T为什么类型，String都是父类，所以可以用String来进行擦除。



Q：**泛型不能用于数组**

因为泛型是不可变性，而数组具有协变性。协变性是指比如B是A的基类，那么B[]也是A[]的基类。举个例子`Object[] obj = new String[10];`是可以编译通过的，即子类数组实例可以赋值给父类数组实例，但是运行无法通过（因为数组类型是在运行时才确定的），所以允许泛型创建数组，泛型数组也必然具有协变性，但泛型本身不具有，所以二者冲突。



Q：**什么是反射？**

反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力

是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

Java反射机制主要提供了以下功能：

- 在运行时判断任意一个对象所属的类。
- 在运行时构造任意一个类的对象。
- 在运行时判断任意一个类所具有的成员变量和方法。
- 在运行时调用任意一个对象的方法。 



Q：**什么是 java 序列化？什么情况下需要序列化？**

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。

什么情况下需要序列化：

a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；
b）当你想用套接字在网络上传送对象的时候；
c）当你想通过RMI（remote method invoke,即远程方法调用）传输对象的时候；



Q：**如何实现序列化**

- 实现Serializable接口，是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。
- 实现Externalizable接口，必须实现writeExternal()、readExternal()方法来自定义序列化。**特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象**

| 实现Serializable接口                                         | 实现Externalizable接口   |
| ------------------------------------------------------------ | ------------------------ |
| 系统自动存储必要的信息                                       | 程序员决定存储哪些信息   |
| Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持 | 必须实现接口内的两个方法 |
| 性能略差                                                     | 性能略好                 |



Q：**Java序列化中如果有些字段不想进行序列化，怎么办？**

对于不想进行序列化的变量，使用transient关键字修饰。

transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。



Q：**如何实现对象克隆**

1.实现Cloneable接口,并重写object类中的clone方法,可以实现浅克隆,也可以实现深度克隆。 

2.实现Serializable,通过对象的序列化和反序列化实现克隆,可以实现真正的深克隆。 

3.利用BeanUtils,apache和spring都提供了这个bean工具。只是他也是浅克隆。



Q：**深拷贝和浅拷贝区别是什么？**

- 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化
- 深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变







## Java容器



###  简述Java容器

![](https://img2018.cnblogs.com/blog/402670/201911/402670-20191117185306543-1130864512.png)

 Java容器有三大接口：Set、List和Map，Set和List用来存放单个对象；Map是键值对。两个工具类：Collections和Arrays

* Set：集合，用来存放互不相同的对象。实现类有HashSet、TreeSet
* List：链表。实现类有ArrayList、LinkedList、Vector
* Map：用来存放键值对。实现类有HashMap、TreeMap和linkedHashMap

### List接口下的实现类



**ArrayList**

 ArrayList底层是Object[]数组

* 构造方法：有三个构造方法。分别是空参构造、自定义初始数组长度的构造、可以传入特定集合元素的构造。

* ArrayList采用懒加载的机制，通过空参的构造方法new的时候，会生成一个空的数组，在第一次put的时候，才会去扩容，初始容量是10。

  * 阿里的Java开发手册建议，最好是调用事先传入数组容量参数的构造方法，可以避免扩容导致的性能问题。所以说在add大量元素之前最好先调用ensureCapacity()方法，减少重新扩容的次数。

  * 普通方法：最常用的就是增删改查，add(E e)、remove(int index)、clear()、set(int index, E e)、get(int index)、isEmpty()判断是否为空、size()判断元素的个数。

  * 扩容机制：

    * 以无参构造ArrayList的时候，初始化赋值的是一个空数组、对数组添加元素时，才会扩容。

    * 在调用add()方法时，会先调用ensureCapacityInternal()方法判断是否需要扩容，该方法主要是通过当前元素的数量和数组大小进行比对来判断的。

    * 如果当前元素数量大于数组大小，则会执行grow()方法进行扩容。

    * 在grow()方法中，数组每次都会被扩容成原来的1.5倍，扩容之后会检查新容量是否大于最小需要的容量，如果还是小于最小容量，则把最小容量当作数组的新容量。检查新容量是否超过了ArrayList定义的最大容量，如果超出了，则比较数组元素的个数，如果大于定义的最大容量，则新容量为Integer.MAX_VALUE，否则为定义的最大容量。

      

**LinkedList**

LinkedList底层是双向链表，可以当作双端队列使用。每个节点都有一个前驱（之前前面节点的指针）和一个后继（指向后面节点的指针），既然是链表实现那么它的随机访问效率比ArrayList要低。

* 构造方法：LinkedList没有长度的概念，所以不存在容量不足的问题，因此不需要提供初始化大小的构造方法，因此提供了两个构造方法。第一个是创建空的链表，第二个是将一个指定的集合添加到LinkedList中，先完成初始化，在调用添加操作。

* add(E e)：添加方法默认是添加到LinkedList的尾部，内部调用了linkLast()方法。首先将last指定的节点赋值给l节点，然后新建节点newNode ,此节点的前驱指向l节点，data = e , next = null , 并将新节点赋值给last节点，它成为了最后一个节点，根据当前List是否为空做出相应的操作。若不为空将l的后继指针修改为newNode。size++， modCount++。

* remove(Object o)，删除指定元素的方法，先循环遍历列表，找到item == o 的节点，在调用unlink()方法删除

* remove(int index)，删除指定下标的方法，先对size减半，如果index > size一半的话，从链表尾部找，否则从头部找，这样可以加快查询的效率。

  

**ArrayList和LinkedList对比**

* 底层数据结构不一样：ArrayList底层是数组，一开始就需要定义好容量，小于数组元素个数需要扩容；LinkedList底层是双向链表，
* 增删改查操作：ArrayList的底层是数组，所以随机查找的效率比LinkedList要高，时间复杂度是O(1)；LinkedList的话需要从链表首部或者尾部遍历定位，时间复杂度是O(n)。ArrayList的插入和删除开销很大，因为底层是数组，需要对数组进行移位操作，如果容量不够的话，还需要扩容；LinkedList定位到需要插入或者删除的位置之后，只需要改变前后指针就好了，所以效率要高。
* 内存空间占用方面：LinkedList需要更多的内存，因为LinkedList除了存储元素本身之外，还要存前后指针

### Set接口下的实现类



**HashSet**

HashSet底层其实是HashMap，其中的元素其实放在HashMap的key上，Value统一为固定对象。

他的add()方法调用的是底层HashMap中的put()方法，往集合里插入元素，会判断key存不存在，如果不存在则插入。判断key是否存在就要重写equals和hashcode方法。

get()方法也同hashmap



**LinkedHashSet**

 与HashSet不同的是，他的Node节点还存着一个指针，指向下一个插入的Node，所以它支持顺序遍历。



**TreeSet**

 与HashSet不同的是支持定制排序，底层是红黑树结构。



**三者的使用场景**

如果仅仅需要存储互不相同的内容的话，HashSet；如果需要实现对set中内容的按顺序遍历的话，用LinkedHashSet；如果想实现定制排序的话，可以用TreeSet



### Map接口下的实现类



**HashMap**

 JDK1.7的底层数据结构是数组+链表；JDK1.8的底层数据结构是数组+链表+红黑树

HashMap通过key的HashCode经过扰动函数处理后得到Hash值，然后通过(n - 1) & hash值来判断元素存放的位置(n为数组长度)，如果当前位置存在元素的话，就判断该元素与要存入元素的hash值以及key是否相同，如果相同，则直接覆盖，不同的话，采用拉链法解决hash冲突，如果单个slot的链表长度大于8并且当前数组长度大于等于64，则会转为红黑树，小于6会转为普通的链表。

* 为啥HashMap的长度是2的幂次方？

  * 插入元素时，得到元素的hash值，可以将模除运算转化为位运算，单条指令就能完成，提高计算效率：`hash % arr.length = hash & (arr.length - 1)`
  * 扩容后，需要将原来数组中的元素添加到扩容后的数组中，2的幂数方便计算。举个例子：原HashMap容量为4，扩容后容量为8，下标为0的元素（其hash值后两位必为0）会被分在0或者4中（分成两类），因为hash & (arr.length - 1)，如果换成其他倍数，瓜分就比较混乱了。

* HashMap多线程操作的问题（设计的时候压根就没考虑过并发）

  * 循环链表：1.7之前HashMap解决Hash冲突是用的头插法，多个线程在操作同一个slot的时候，在HashMap正好扩容，移动数组元素时容易发生死循环。
  * size不正确：HashMap有一个size字段是存储整个map中的元素个数，put方法的后面size会加1，这个操作不是原子的，如果多个线程执行这行代码，结果大概率不正确。
  * 数据丢失：比如两个线程put不同的元素，这两个元素put的位置都是同一个slot，slot原来有一个元素c，线程同时操作的最终结果是只有一个被写入，另一个被覆盖。

* HashMap遍历：迭代器、增强for循环、lambda表达式、Streams API。

  ```
  for (Map.Entry<Integer, String> entry : map.entrySet())
  ```

  ```
  for (Integer key : Map.keySet())
  ```

  ```
  Iterator<Map.Entry<Integer, String>> itreator = Map.entrySet().iterator();
  ```

  ```
  Iterator<Integer> iterator = map.keySet().iterator();
  ```

  ```
  map.forEach((key, value) - > {sout(key);sout(value);})
  ```



**ConcurrentHashMap**

 线程安全的HashMap，底层数据结构：1.7的底层采用分段的数组+链表实现；1.8采用和HashMap相同的数据结构，也是数组+链表+红黑树。

* 不同JDK下的对比

  * 1.8并发采用synchronized+CAS来操作的，锁的粒度更细，支持更高的并发量。
  * 1.7中一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。
  * 1.8中ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))。synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。

* 底层实现原理：

  * put()：总的来说其实就是对当前的table进行无条件自循环直到put成功

    * 根据key值计算hash值
    * 遍历数组table
      * 如果数组中该位置为空，则使用CAS操作将该值放入该位置。
      * 如果数组中该位置首个元素的hash值等于MOVED，说明正在扩容，则该线程会帮助数据迁移。
    * 如果遍历后不满足上述两个条件，则会执以下逻辑：
      * 获取数组该位置的首节点的监视器锁
      * 首节点 hash 值大于 0，说明是链表，链表遍历插入值
      * 否则为红黑树，使用红黑树的 putTreeVal 方法，插入新值
      * 如果以上执行的是链表操作，判断链表长度是否达到限定值，是否需要转换为红黑树

  * get()：get不需要加锁，计算当前key的hash值，然后定位到对应的数组下标，如果首节点的hash值为MOVED，则帮助扩容，否则通过equals()方法来查找对应的元素。

  * 为什么get()不需要加锁？场景无非就是读读、读写。读读是不会造成数据安全问题的，读写的话，因为ConcurrentHashMap的value是用volatile修饰的，可以保证被修饰变量的可见性，所以读到的永远是最新的数据，而且内存屏障，会使得读一定是在写的后面。

  * 扩容操作：当数组中元素达到了sizeCtl数量的时候，就会调用transfer()方法来进行扩容，这种扩容是并发的。

    * 单线程新建nextTable，扩容为原table容量的两倍。 

    * 每个线程想增/删元素时，如果访问的桶是ForwardingNode节点，则表明当前正处于扩容状态，协助一起扩容完成后再完成相应的数据更改操作。 

    * 扩容时将原table的所有桶倒序分配，每个线程每次最小分16个桶进行处理，防止资源竞争导致的效率下降， 每个桶的迁移是单线程的，但桶范围处理分配可以多线程，在没有迁移完成所有桶之前每个线程需要重复获取迁移桶范围，直至所有桶迁移完成。 

      

**TreeMap**

 底层是红黑树，能够把它保存的记录根据键排序。默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。



**LinkedHashMap**

 LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。



### Collections工具类

Collections主要的功能是排序（反转、交换等）、查找（二分查找某元素、定制排序、统计某个元素出现的次数）、替换（新元素替换旧元素）和同步控制（将指定集合包装成线程同步的集合）



# 并发



## synchronized和volatile



**Q：讲下synchronized？**

* synchronized关键字解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

* 在 Java 早期版本中，synchronized 属于 重量级锁，效率低下。

* 因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。

* 庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

  

**Q：怎么用**

1、修饰实例方法，进入代码块要获得**对象实例**的锁
2、修饰静态方法，类锁，不属于任何实例。进入同步代码块要获得当前的class锁，与实例锁互斥。
3、修饰代码块，指定一个加锁对象，表示进入同步代码块前要获得给定对象的锁。



**Q：底层实现原理**

* 属于JVM层面。在修饰代码块的情况下，使用的是monitorenter和monitorexit指令，其中monitorenter指向的是同步代码块的开始位置、monitorexit指向的是同步代码块结束位置。在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。

* 修饰方法的情况下，并没有这两个指令，取得代之的则是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

* 无论是同步方法还是同步代码块，本质都是对存在于对象头部中的监视器monitor的获取。

  

**Q：锁升级**

 synchronized锁升级顺序是无锁、偏向锁、轻量级锁、重量级锁。

* 无锁：对象刚创建时，是无锁状态，即偏向锁的标志位为01，状态是0

* 偏向锁：当线程执行到临界区，会利用CAS操作，将线程ID插入到Mark word和栈帧中的锁记录中，同时修改锁的偏向标志位，设置状态为1，表明获得偏向锁。在接下来的执行中，只要该锁没有被其他线程获取，没有其他线程来竞争，那么持有该偏向锁的线程永远不需要执行同步操作。也就是说，再次进入同一段同步代码块，不需要加锁解锁了。流程是这样的，判断当前线程是否与Mark Word中的线程id一致，若一致，则线程已经成功获得锁，继续执行；若不一致，检查偏向锁的状态，如果没有偏向锁，利用CAS竞争锁，也就是第一次获取锁的操作。如果两个及以上线程来竞争，即CAS失败一次，则偏向锁失效，膨胀为轻量级锁。

* 轻量级锁（自旋锁）：加轻量级锁之前要撤销偏向锁。偏向锁是在竞争出现才会释放锁，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。在一个安全点（该时间点上没有字节码运行），停止拥有偏向锁的线程，检查该线程是否还活着，如果不处于活动状态，则将对象头设置为无锁状态；否则遍历线程栈，如果存在锁记录，则修复锁记录和mark word，使其变为无锁状态，最后唤醒当前线程，将锁升级为轻量级锁。所以如果某些同步代码块大多数情况下都是有两个线程以上竞争的话，直接将其设置为轻量级锁。**锁标志位为00表示轻量级锁。**

  * 轻量级锁有两种:自旋锁和自适应自旋锁。自旋锁就不多赘述，都知道了。自旋锁和自适应自旋锁的区别在于，自适应锁是动态的根据实际情况来改变自旋次数的，大概原理就是如果有线程曾经获得过该锁，就增加自旋的次数。轻量级锁也称非阻塞同步、乐观锁。
  * 线程时间片到了，自旋锁也要滚蛋，呵呵。自旋锁毕竟还是JDK层面的。

* 重量级锁：当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cpu。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。

  --------------------------------------------------------------------------------

**Q：Volatile作用及实现原理**

volatile 的底层实现原理是内存屏障

1. 对 volatile 变量的写指令**后**会加入写屏障
2. 对 volatile 变量的读指令**前**会加入读屏障

* 保障有序性：
  * LoadLoad：保证该屏障前的读操作在屏障后的读操作之前
  * StoreStore：保证屏障前的写操作在屏障后的写操作之前
* 保障变量的可见性
  * LoadStore：屏障后的写操作在读操作之后
  * StoreLoad：屏障前的写操作刷回主存，后续的读操作才可继续
  * 在具体一点的实现细节
    * 程序遇到内存屏障，对操作系统声言一条Lock前缀的指令，会引起处理器缓存回写到内存。早期的处理器是锁总线，处理器独占内存，待操作完被修饰的变量后释放锁；如果访问的数据已经被缓存在处理器内部，则处理器不会声言Lock信号了，而是锁定这块内存区域的缓存并强制刷新回主内存，同时MESI协议保证修改操作的原子性，可以阻止两个或两个以上的处理器同时修改缓存的内存区域的数据。
    * 一个处理器的缓存回写到内存会导致其他处理器的缓存无效，如果读取该变量的话，会强制读主内存。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。



## locks包

locks包是JUC下的一个包，提供了很多基于JDK的一些线程同步的方法、还有一些原子操作的类。这些方法通过继承AQS这个类来实现的。包括有ReentrantLock、ReadWriteLock、CountLatch等同步锁，还有atomic原子包，还有一些线程安全的容器和阻塞队列，比如ConcurrentHashMap、ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序、LinkedBlockingQueue、SynchronousQueue：是一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列等。

**Q：AQS实现原理**

AQS其实就是一个构建锁和同步器的框架，它的核心思想就是，如果被请求的资源是空闲的，那么将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个线程等待机制 AQS 是用FIFO队列（虚拟的双向队列）来实现的，即将暂时获取不到锁的线程加入到队列中，共享资源是用一个int型的数表示的，0表示当前资源不可用。

* 同步队列实现机制：
  * 独占式获取：首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法保证线程安全的获得同步状态，如果同步状态获取失败，则构造同步节点，并通过addWaiter(Node node)方法尝试将该节点线程安全的加入到同步队列的尾部，加入成功后，调用acquireQueued(Node node， int arg)方法，使节点以死循环的方式获取同步状态（1、判断前驱节点是否为头节点，2、是否能获得同步状态）。如果获取不到，则阻塞节点中的线程，被阻塞的线程的唤醒依靠**前驱节点**的出队或阻塞线程被中断来实现。
  * 共享式获取：线程尝试调用tryAcquiredShared()方法获取同步状态，如果返回值大于等于0，则获取成功。否则加入同步队列，以自旋的方式获取同步状态，获取同步状态就是前驱节点为头节点并且成功获取同步状态。
* 为什么要只有在前驱节点为头节点才可以获取同步状态？
  * 成功获取到同步状态的永远是头节点，当头节点释放后，才会唤醒后继节点
  * 节点和节点之间循环检查的时候不通信，通过判断自己的前驱是否为头节点，维护FIFO的规则，也便于对过早通知的处理。
* Condition怎么实现：是AQS的一个内部类，底层的数据结构是FIFO队列，队列的每个节点包含了对一个线程引用，该线程就是在Condition对象上等待的线程。当线程调用Condition.await()方法后，将会以当前线程构造节点，并将节点从尾部加入等待队列，更新尾节点的操作并不是CAS的，因为调用await()方法的线程必定是获取了锁的。当调用signal()方法后，将会唤醒等待队列中的等待时间最长的节点，唤醒队列前，会将节点移到同步队列中。在移动到同步队列之前，会先检查是否为获得了锁的线程，然后调用AQS的enq()方法，将等待队列的首节点安全的移动到同步队列的尾部，使用LockSupport唤醒该节点的线程。

AQS可重写五个方法：

独占式：tryAcquire()、tryRelease()；共享式：tryAcquireShared()、tryReleaseShared()；判断线程是否独占资源：isHeldExclusively()



**Q：Lock接口**

定义了一些锁获取和释放的基本操作，lock()、tryLock()、lockInterruptibly()、unlock()等，Lock接口的实现基本上要聚合一个AQS的子类来完成线程访问控制。



**Q：ReentrantLock如何实现的**

可重入锁有一个静态内部类Sync，这个类继承了AQS，并且通过实现AQS的抽象方法来完成管理同步状态，同步状态使用一个int型的变量来表示的，可以使用AQS提供的三个方法来对状态进行改变，分别是set()、get()、compareAndSetState()，从而完成对可重入锁的设计。

* 可重入非公平锁的设计：

  * 先调用getState()获取当前state的值，如果是0，则代表当前无线程操作共享资源，利用compareAndSetState()将0设置为acquires，若设置成功，则设置当前线程独占，返回true，表示加锁成功；
  * 如果state的值不为0，判断当前线程是否为独占线程，如果是，则利用setState(currentState + acquires)，将当前state的值设置为state + acquires。
  * 释放的话，先利用getState()获取当前state的值，然后减去releases，判断减去后的状态是否为0，若为0，设置当前独占资源的线程为null，并利用setState()设置更新后的值，为0返回true，否则返回false；

* 公平锁的设计：

  * 公平锁的设计和可重入非公平锁的设计大致一样，只是在调用compareAndSetState()时，新增了一条判断语句，hasQueuedPredecessors()，用来判断加入了同步队列的当前节点是否有前驱节点，如果是的话加锁，不是的话进入AQS内置的队列等待。

    

**Q：读写锁的设计**



**Q：Semaphore 原理**

其中有一个信号量permits，用来限制能同时访问共享资源的线程上限

执行 `acquire` 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 `release` 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。然而，其实并没有实际的许可证这个对象，`Semaphore` 只是维持了一个可获得许可证的数量。 `Semaphore` 经常用于限制获取某种资源的线程数量。

`Semaphore` 有两种模式，公平模式和非公平模式。

- **公平模式：** 调用 acquire 的顺序就是获取许可证的顺序，遵循 FIFO；
- **非公平模式：** 抢占式的。



**Q：CountDownLatch 与 CyclicBarrier 的原理**

CountDownLatch：用来进行线程同步协作，可以让一个线程等待其他所有线程完成操作后再继续运行，`CountDownLatch` 是共享锁的一种实现,它默认构造 AQS 的 `state` 值为 `count`。当线程使用 `countDown()` 方法时,其实使用了`tryReleaseShared`方法以 CAS 的操作来减少 `state`,直至 `state` 为 0 。当调用 `await()` 方法的时候，如果 `state` 不为 0，那就证明任务还没有执行完毕，`await()` 方法就会一直阻塞，也就是说 `await()` 方法之后的语句不会被执行。然后，`CountDownLatch` 会自旋 CAS 判断 `state == 0`，如果 `state == 0` 的话，就会释放所有等待的线程，`await()` 方法之后的语句得到执行。

CyclicBarrier：循环栅栏，用来进行线程协作。基于 `ReentrantLock`和 `Condition` 的。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，所有线程继续执行



**Q：CountDownLatch 与 CyclicBarrier 的区别？**

- CountDownLatch：减计数方式，state计算为0时释放所有等待的线程，并且无法重置、重新利用。
- CyclicBarrier ：加计数方式，state计数达到指定值时释放所有等待线程，并且计数置为0重新开始、可重复利用



**Q：atomic包**

四大原子类：基本类型：整形、长整型、布尔型；数组类型：整形数组、长整型数组、引用类型数组；引用类型；对象的属性修改类型

* AtomicInteger的使用

  ```
  get():获取当前的值
  getAndSet(int newValue)：获取当前的值，并设置新的值
  getAndIncrement()：获取当前的值，并自增
  getAndDecrement()：获取当前的值，并自减
  getAndAdd(int delta)：获取当前的值，并加上预期的值
  compareAndSet(int expect, int update)：如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）
  lazySet(int newValue)：最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值
  ```

  * 实现原理
    利用CAS+volatile+本地方法来保证原子操作。
    CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。

    

## 比较

**Q：synchronized和ReentrantLock/lock区别**

* 前者是基于JVM实现的，JVM会自动释放锁、后者是基于JDK，需要手动释放锁

* ReentrantLock功能更加灵活，总的来说有三点：

  * 等待可中断：正在等待的线程可以选择放弃等待，改为处理其他事情。
  * 可实现公平锁：先等待的线程可以优先获得锁
  * 可实现选择性通知（锁可以绑定多个条件）：借助于condition接口和newCondition()方法可以更加灵活的实现等待/通知的机制。可以实现多路通知机制，因为一个Lock对象可以创建多个condition（对象监视器），即一个同步队列和多个等待队列，线程对象可以注册在指定的condition中，有选择的进行线程通知。

* 性能分析：

  * synchronzied：托管给JVM执行的，1.6之前是很低效的，因为采用的是CPU悲观锁机制，即线程获得的是独占锁，新来的线程只能依靠阻塞来等待线程释放锁，CPU转换线程阻塞时会引起线程上下文切换，多线程竞争会导致效率很低。1.6之后引入了锁升级，所以性能有所提高。
  * ReentrantLock：基于JDK实现的，使用的是乐观锁机制。每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。ReentrantLock其实是用了AQS中的compareAndSetState()方法来实现的乐观锁操作，该方法是调用了Unsafe类中的一个方法，该方法是native方法，用C++写的。

* 使用场景

  * 在比较复杂是使用同步应用下，建议使用lock，比如需要某个线程在等待另一个线程的时候，需要进行中断；或者是需要灵活的实现等待通知机制，Condition可以灵活的通知具体的某个线程；或者是需要实现公平锁、读写锁等。

    

**Q：volatile和synchronized**

* volatile 关键字是线程同步的轻量级实现，所以 volatile 性能肯定比synchronized关键字要好（不会引起线程上下文切换） 。但是 volatile 关键字只能用于变量而synchronized 关键字可以修饰方法以及代码块 。

* volatile 关键字能保证数据的可见性，但不能保证原子性。synchronized 关键字两者都能保证。

* volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。

  

**Q：wait、sleep、join、yield**

* sleep：Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU，提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁，即其他线程无法获得同步锁，可通过调用interrupt()方法来唤醒休眠线程。
* yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。
* wait：Object类的方法(notify()、notifyAll() 也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁
* join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。
* **sleep、yield比较异同**：
  *  等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。
  *  sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
  *  线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；
  *  sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；
  *  sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。



**Q：wait/notify和park/unpark**

* wait和notify都是Object中的方法,在调用这两个方法前必须先获得锁对象，但是park不需要获取某个对象的锁就可以使某个线程进入waiting状态。
* notify只能随机选择一个线程唤醒，无法唤醒指定的线程，unpark却可以唤醒一个指定的线程。而且unpark()的时候，不需要当前线程获取锁，在下次锁的时候，会抵消掉，相当于免死金牌。



## JMM

* 早期的Java的内存模型实现是直接从共享内存读取变量。但是当下的JMM中，线程可以把变量保存在本地内存，而不是直接在主存读写，就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。所以JMM用来解决多线程通过共享内存进行通信时，存在的原子性、可见性及指令有序性的问题。

* 原子性：使用锁/循环CAS

  * 锁：可以保证只有获得锁的线程操作锁定的内存区域
  * volatile+循环CAS：每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。

* 可见性：volatile

* 指令有序性：通过插入内存屏障

  * LoadLoad：保证该屏障前的读操作在屏障后的操作之前

  * StoreStore：保证屏障前的写操作刷新回主存

  * LoadStore：屏障后的写操作在读操作之后

  * StoreLoad：屏障前的写操作刷回主存，后续的读操作才可继续

    

## ThreadLocal和线程池

**Q：ThreadLocal**

 ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据，相当于空间换时间。

 如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而从根本上避免了线程安全问题。

* 实现原理

  * ThreadLocal有一个静态内部类ThreadLocalMap，存放了以ThreadLocal对象为key、Object对象为value的键值对。ThreadLocal调用set()、get()方法的时候，其实是调用了ThreadLocalMap类对应的set()、get()方法。

* 内存泄露问题

  * ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法

* 为什么ThreadLocalMap中的Entry使用弱引用

  * 在ThreadLocalMap中的get()和set()方法中，会对key为null进行判断，如果为null，会将对应value置为null。这意味着使用完ThreadLocal，当前线程依然运行的前提下，就算忘记调用remove()，弱引用可以多一层保障，保障value的正常清除，从而避免内存泄漏。

* ThreadLocal和Synchronized

  * Synchronized侧重点是多个线程之间访问资源的同步

  * ThreadLocal是用空间换时间，使每个线程之间的数据相互隔离，使得程序拥有更高的并发性

    

**Q：线程池**

* 池化思想：

  * 创建和关闭线程都要花费时间，为每一个任务都创建一个线程，甚至会出现创建和销毁的时间大于执行的时间，得不偿失。
  * 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗；提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行；提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

* 创建线程池：

  * 不要用Executors去创建，而是通过ThreadPoolExecutor的方式。
    * 用Executors创建有两个问题：允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求；允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。
  * 线程池核心参数：
    * corePoolSize：核心线程数。最小可以同时运行的线程数量
    * maximumPoolSize：最大线程数。当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数
    * workQueue：队列容量。当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中
    * 其他常见参数：
      * keepAliveTime：等待时间。当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁。
      * unit：等待时间的单位
      * threadFactory：executor创建新线程的时候会用到
      * handler：饱和策略。如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满时，定义一些策略。
        * 拒绝新任务处理，抛出异常
        * 调用执行自己的线程运行任务
        * 不处理新任务，直接丢弃
        * 丢弃最早未处理的任务

* execute()和submit()

  * execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否
  * submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。

* 使用流程：

  * 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则从核心线程池中创建一个新的线程来执行任务。如果是，则进入下一步；

  * 判断核心线程数是否满，不满则新建一个线程；否则判断工作队列是否满了，未满，则加入工作队列等待；已满，判断最大线程数是否满了，未满，则创建新的线程；已经满了，执行对应的饱和策略，比如说拒绝并抛出异常、直接丢弃等。

    

# JVM

## Java内存区域

 Java虚拟机会在执行程序的过程中，把它所管理的内存划分为若干个不同的数据区域。区域主要分为线程私有的和共有的。私有的是程序计数器、虚拟机栈、本地方法栈；公有的是堆、方法区。

* 程序计数器：CPU时间片到了，或者由于其他原因中断时，程序计数器用来记录当前线程执行的位置，方便上下文切换
* 虚拟机栈：是Java方法执行的线程内存模型。每个方法被执行，JVM会创建一个栈帧，存储着局部变量表、操作数栈、动态链接、方法出口等信息。方法被调用是入栈、执行完毕是出栈。
* 本地方法栈：一些带有**native关键字**的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法。本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出`StackOverFlowError` 和 `OutOfMemoryError`异常
* 堆：用于存放对象实例。可以处于物理上不连续的空间，但是逻辑上被视为连续
  * 字符串常量池：存放着字符串对象以及字符串常量值
  * 静态变量、class对象也在堆中
* 方法区：存放被虚拟机加载的类信息、JIT编译后的代码缓存。8之前永久代实现、8及8之后用元空间
  * 运行时常量池：为方法区中的一部分。用于存放编译期间生成的字面量和符号引用。在运行期间，也可以将新的常量放入池中。 

**Q：为什么JDK8要用元空间实现方法区**

* 用永久代容易造成OOM的问题
* Oracle公司想把JRocket的一些优秀功能集成到HotSpot中，但是两者的方法区实现方法不同，为了未来HotSpot的发展，改了。



## Java对象



**Q：对象创建的过程**

 此处讨论的是Java普通对象，不是数组对象和Class对象。

* **类加载检查**：首先JVM遇到一条字节码new指令时，会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载、验证、解析、初始化过，如果没有，会去执行相应的类加载过程。
* **分配内存**：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。有两种分配方式：第一个是指针碰撞，即把使用过的内存和未使用过的内存各放一边，中间有一个指针作为分界线，分配的时候挪动指针就好了；第二个方法是空闲列表，即虚拟机维护一个列表，记录着可用的内存块，分配的时候找到一块足够大的空间分配给对象实例，并更新表。由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
* **初始化零值**： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
* **设置对象头**：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
* **执行init方法**：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。



**Q：Java对象内部构造**

* 对象内部：对象头、对象实例、对齐填充。其中对象头包含两类信息。
  * 存储对象自身运用时数据（Mark Word）。如哈希码、GC年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等
  * 类型指针。通过指针判断该对象是哪个类的实例。



## 垃圾收集



**Q：垃圾判断算法**

* 引用计数法：

  给对象添加一个引用计数器，当一个对象被引用，则引用数+1，当引用数为0时，则表示可以回收。

  这种方法可以通过Recycler算法来解决循环引用的问题，但是在多线程环境下，引用计数变更需要进行昂贵的同步操作。

* 可达性分析：从 GC Root 开始进行对象搜索，可以被搜索到的对象即为可达对象，此时还不足以判断对象是否存活/死亡，需要经过多次标记才能更加准确地确定，整个连通图之外的对象便可以作为垃圾被回收掉。目前 Java 中主流的虚拟机均采用此算法。

  * 可作为GC Roots的对象：
    1、虚拟机栈或者本地方法栈中引用的对象
    2、方法区中类静态属性引用的对象
    3、方法区中常量引用的对象
     4、Java虚拟机内部的引用。如基本数据类型对应的Class对象、一些常驻的异常对象（空指针异常、内存溢出等）
    5、所有被同步锁持有的对象
       \* 二次标记：对于被标记要回收的对象，会进行筛选，判断的条件是是否有必要执行finalize()方法，如果有，则会加入一个队列，收集器会对该队列进行二次标记，如果在此阶段该对象可达，则可以逃脱GC。

* 判断哪个类需要回收？

  * 该类的所有实例都被回收
  * 加载该类的加载器已经被回收
  * 该类对应的Class对象没有在任何地方被引用，并且无法在任何地方通过反射访问该类的方法。



### 垃圾收集算法

* **标记-清除**：

  回收过程主要分为两个阶段，第一阶段为追踪（Tracing）阶段，即从 GC Root 开始遍历对象图，并标记（Mark）所遇到的每个对象，第二阶段为清除（Sweep）阶段，即回收器检查堆中每一个对象，并将所有未被标记的对象进行回收，整个过程不会发生对象移动。整个算法在不同的实现中会使用三色抽象（Tricolour Abstraction）、位图标记（BitMap）等技术来提高算法的效率，存活对象较多时较高效。执行效率不稳定、产生内存碎片

* **标记-整理**：

  这个算法的主要目的就是解决在非移动式回收器中都会存在的碎片化问题，也分为两个阶段，第一阶段与 Mark-Sweep 类似，第二阶段则会对存活对象按照整理顺序（Compaction Order）进行整理。主要实现有双指针（Two-Finger）回收算法、滑动回收（Lisp2）算法和引线整理（Threaded Compaction）算法等。对象移动会终止所有用户线程，效率低

* **标记-复制**：

  将空间分为两个大小相同的 From 和 To 两个半区，同一时间只会使用其中一个，每次进行回收时将一个半区的存活对象通过复制的方式转移到另一个半区。有递归（Robert R. Fenichel 和 Jerome C. Yochelson提出）和迭代（Cheney 提出）算法，以及解决了前两者递归栈、缓存行等问题的近似优先搜索算法。复制算法可以通过碰撞指针的方式进行快速地分配内存，但是也存在着空间利用率不高的缺点，另外就是存活对象比较大时复制的成本比较高。空间浪费、不适合对象存活率高的情况

* **分代回收**：

  把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次都有大量对象死亡，有老年代作为内存担保，采取复制算法。而老年代中，对象存活时间长，采用标记整理，或者标记清理算法都可

  - 新创建的对象都被放在了新生代的伊甸园中

  - 当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 **Minor GC**

    - Minor GC 会将伊甸园和幸存区FROM存活的对象先复制到幸存区 TO 中， 并让其寿命加1，再清除垃圾对象，再交换两个幸存区
    - 再次创建对象，若新生代的伊甸园又满了，则会再次触发 Minor GC，并让幸存区中的对象寿命加1
    - 如果幸存区中的对象的寿命超过某个阈值（最大为15，4bit），就会被放入老年代中

  - 如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发**Full GC**，扫描新生代和老年代中所有不再使用的对象并回收

    

### 垃圾收集器

1、**CMS**：以获取最短回收停顿时间为目标的收集器，分代收集。

* 四个步骤：
  * 初始标记：标记GC Roots能直接到的对象，速度很快。但是STW
  * 并发标记：进行GC Roots Tracing 的过程，找出存活对象且用户线程，可与用户线程并发执行
  * 重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在STW问题
  * 并发清除：对标记的对象进行清除回收，可以与用户线程同时进行
* 三个缺点：
  * 对处理器资源很敏感。并发阶段，虽然不会导致用户线程停顿、但是会占用一部分线程导致应用程序变慢，降低总吞吐量。
  * 无法处理浮动垃圾。在CMS的并发标记和并发清理阶段，用户线程还在进行，会不断的有新对象生成，但是这一部分对象出现在标记阶段之后，就无法被清理了，只能等到下一次清理。**所以这就导致了CMS不能像其他收集器一样等到老年代几乎被填满了再去收集**，需要预留出一部分空间，但是如果预留的这部分空间无法满足对象分配的话，会并发失败，导致**FULL GC**
  * 因为是基于标记清除，会造成大量碎片。会给大对象分配带来问题，严重时触发**FULL GC**

2、**G1收集器**：目标是在追求低延迟的前提下，尽可能地提高吞吐量，具有优先级的区域回收方式。与之前的垃圾收集器不同：把连续的堆分为多个大小相等且独立的区域，每一个区域都可以充当新生代的Eden空间、Survivor空间或者是老年代空间，是一种动态集合。收集器对于不同的区域采用不同的策略进行回收。区域中留有一部分是专门存储大对象的。可以在后台维护优先级列表，对价值大的区域优先回收，比如回收时间短、回收所获得的空间大。

* 四个步骤：
  * 初始标记：标记GC Roots能直接关联到的对象，并修改TAMS（Top at Mark Star）指针的值，便于让下一阶段用户线程并发运行时，正确的在区域中分配新对象。STW
  * 并发标记：可达性分析，扫描整个堆，找出要回收的对象。扫描完成后，还需要重新处理原始快照记录下的在并发时有变动的对象。**此阶段之前会有一个可中断的并发预清理，减少并发标记时间**，防止跨代引用，搜索时间变长。
  * 最终标记：处理并发阶段留下的少量的快照记录。STW
  * 筛选回收：对各个区域的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划。回收的大致思路是，把决定回收的那一部分区域的存活对象**复制**到空的区域中，再清理掉旧的。因为需移动存活对象，此阶段也是STW，此阶段STW耗时较长，因为未能解决转移过程中准确定位对象地址的问题。
* 优点：可以指定最大停顿时间，可以实现定制化；不会产生内存碎片，有利于程序长时间运行。
* 缺点：G1的为了垃圾收集产生的内存占用和额外负载都比CMS要高。因为要解决跨代引用问题，G1在每个区域都要维护一张卡表，占用了大量的堆容量；G1不仅要用写后屏障更新维护卡表，还要实现原始快照搜索算法，负载更大。
* G1的四个STW：
  * 初始标记阶段，只标记GC ROOTS；再标记阶段对象数量少，这两个STW的时间较短
  * 清理阶段因为内存分区数量少，耗时也较短
  * 转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。为什么转移阶段不能和标记阶段一样并发执行呢？**主要是G1未能解决转移过程中准确定位对象地址的问题**。

3、**ZGC收集器**：通过美团技术团队公众号了解的一款垃圾回收器。JKD11推出的一款低延迟垃圾收集器。ZGC的设计目标是适用于大内存低延迟服务的内存管理和回收，它的停顿时间比G1和CMS更短，虽然ZGC也采用标记复制算法，但是ZGC在标记、转移和重定位阶段几乎都是并发的，所以停顿时间很短。

* **六个步骤**：

  * **初始标记**：扫描所有GC ROOTS，耗时极短。**STW**
  * **并发标记**：类似于G1的重定位阶段
  * **再标记**：再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。**STW**
  * **并发转移准备**：
  * **初始转移**：扫描所有GC ROOTS，耗时极短。**STW**
  * **并发转移**：垃圾收集线程转移对象的过程中，用户线程依然在运行。

* **关键技术**：

  * ZGC通过**着色指针**和**读屏障技术**，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：

    并发转移中“并发”意味着GC线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。而在ZGC中，应用线程访问堆中对象的引用将触发**“读屏障”**，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新到对象的新地址上，这样应用线程始终访问的都是对象的新地址。JVM是通过着色指针来判断对象被移动过。

  * **着色指针**：将一种信息存储在指针中的技术。

    ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间：0~4TB对应这Java堆、其余的分别是[4~8TB]M0地址空间、[8~12TB]M1地址空间、[12~16TB]预留未使用、[16~20TB]为Remapped空间。

    当应用程序创建对象时，首先在堆空间申请一个虚拟地址，但该虚拟地址并不会映射到真正的物理地址。ZGC同时会为该对象在M0、M1和Remapped地址空间分别申请一个虚拟地址，且这三个虚拟地址对应同一个物理地址，但这三个空间在同一时间有且只有一个空间有效。

    与上述地址空间划分相对应，ZGC实际仅使用64位地址空间的第0~41位，而第42~45位存储对象的存活信息，第47~63位固定为0

    地址视图切换过程：

    1、**初始化**：ZGC初始化之后，整个内存空间的地址视图被设置为Remapped。程序正常运行，在内存中分配对象，满足一定条件后垃圾回收启动，此时进入标记阶段。

    2、**并发标记阶段**：第一次进入标记阶段时视图为M0，如果对象被GC标记线程或者应用线程访问过，那么就将对象的地址视图从Remapped调整为M0。所以，在标记阶段结束之后，对象的地址要么是M0视图，要么是Remapped。如果对象的地址是M0视图，那么说明对象是活跃的；如果对象的地址是Remapped视图，说明对象是不活跃的。

    3、**并发转移阶段**：标记结束后就进入转移阶段，此时地址视图再次被设置为Remapped。如果对象被GC转移线程或者应用线程访问过，那么就将对象的地址视图从M0调整为Remapped。

    为了区别前一次标记和当前标记。即第二次进入并发标记阶段后（再标记超过1ms，会再次并发标记），地址视图调整为M1，而非M0。

* GC触发时机：ZGC的核心特点是并发，GC过程中一直有新的对象产生。如何保证在GC完成之前，新产生的对象不会将堆占满，是ZGC参数调优的第一大目标。因为在ZGC中，当垃圾来不及回收将堆占满时，会导致正在运行的线程停顿，持续时间可能长达秒级之久。

  * **阻塞内存分配请求触发**：当垃圾来不及回收，垃圾将堆占满时，会导致部分线程阻塞。我们应当避免出现这种触发方式。
  * **基于分配速率的自适应算法**：最主要的GC触发方式，其算法原理可简单描述为”ZGC根据近期的对象分配速率以及GC时间，计算出当内存占用达到什么阈值时触发下一次GC”。
  * **基于固定时间间隔**：适合应对突增流量场景，定时活动、秒杀。流量平稳变化时，自适应算法可能在堆使用率达到95%以上才触发GC。流量突增时，自适应算法触发的时机可能会过晚，导致部分线程阻塞。



 **Q：CMS收集器和G1收集器的区别**

- 使用范围不同

  CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用

  G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用

- STW的时间不同

  CMS收集器以最小的停顿时间为目标的收集器。

  G1收集器可预测垃圾回收的停顿时间（建立可预测的停顿时间模型）

- 垃圾碎片

  CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片

  G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

- 垃圾回收过程不同

  CMS：初始标记 --> 并发标记 --> 重新标记 --> 并发清除

  G1：初始标记 --> 并发标记 --> 最终标记 --> 筛选回收





 \###四个引用

 \* 强引用：最常见的引用，不会被垃圾回收
 \* 软引用：当发生内存溢出前，被垃圾回收
 \* 弱引用：存活到下一次垃圾回收
 \* 虚引用：不会有任何影响，只是在该对象被垃圾回收时发出信号

### GC相关问题



**Q：分区大小如何选择：**

依赖对象生命周期的分布情况，如果应用存在大量的短期对象，应该选择较大的年轻代；如果存在相对较多的持久对象，老年代应该适当增大。



**Q：为什么要设置动态晋升年龄？**

* 如果固定按照设定的阈值来作为晋升条件。如果设置的过大，则原本应该晋升的对象会一直停留在Survivor区，直到溢出，发生Minor GC，这样的话分代收集的机制就失效了；如果设置的过小，过早晋升的对象不能在新生代被充分回收，大量短期对象进入老年代，频繁引起Major GC，影响GC性能。

* 相同的应用在不同时间表现不同，会导致对象的生命周期发生波动，固定阈值无法适应这种动态变化。

  

**Q：Minor GC频繁：**
新生代较小，Eden区很快被填满，导致频繁minor GC，可以增大新生代空间。如果堆中短期对象多，扩容新生代不会导致GC时间显著增加。



**Q：Remark阶段耗时多**

* Remark阶段必须全堆扫描，因为存在着跨代引用，仅仅扫描老年代的话，有些对象的引用存在于新生代，会被错误回收，新生代对象多，则Remark的阶段耗时就多。这样的话就转化为了如何减少新生代的数量，建议在Remark之前进行一次Minor GC。

* 同样Minor GC时，老年代也会持有新生代的引用，但是这种引用情况很低，可以用卡表来解决。

  * 具体策略是将老年代的空间分为若干卡表，卡表本身是单字节数组，数组中的每个元素对应一张卡，发生老年代引用新生代时，虚拟机将卡对应的卡表元素标记为脏，之后Minor GC时只需要扫描卡表就知道哪些老年代指向新生代了。

    

**Q：什么情况下会发生FULL GC？**（来自[美团技术团队](https://tech.meituan.com/2017/12/29/jvm-optimize.html)）

* 元空间不足

* 并行清理的过程中，老年代空间不足，需尽快回收老年代里面不再被使用的对象，直接转为FULL GC。比如CMS在进行并发清理的过程中，用户线程还在运行，此时突然有一个大对象，以至于新生代和老年代都无法存放。

* 分配担保机制失败

  *  在发生Minor GC之前虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，Minor GC安全；如果小于，则虚拟机继续检查老年代最大连续可用空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试一次Minor GC。

* 主动触发FULL GC来避免碎片问题

* 经常FULL GC应该是老年代设置过小了，或者GC后没有进行压缩

  

**Q：解决跨代引用问题**

利用卡表

具体策略是将老年代的空间分为若干卡表，卡表本身是单字节数组，数组中的每个元素对应一张卡，发生老年代引用新生代时，虚拟机将卡对应的卡表元素标记为脏，之后Minor GC时只需要扫描卡表就知道哪些老年代指向新生代了。

### OOM相关问题

* 堆溢出

  * 如何导致：堆中没有额外的空间去创建对象，同时也无扩大堆空间的情况下会报OOM。
  * 解决方法：通过内存映像分析工具对Dump出来的堆转储快照进行分析。首先确认内存中导致OOM的对象是否是必要的。也就是要分析清楚内存泄漏还是内存溢出。如果是内存泄露，查看对象到GCRoots的引用链，找到泄露对象是与哪些GC Roots相关联，导致了垃圾回收器无法回收，定位到具体的代码位置进行修改；如果是内存溢出，也就是说当前堆中对象都是必要的，这就需要该堆的参数设置了，上调堆的大小，或者是检查代码，看有哪些对象生命周期长、持有状态时间长等问题，进行修改。

* 栈溢出

  * 如何导致：在栈支持动态扩展的情况下，扩展栈容量无法申请到足够的内存时，会抛出OOM；不支持动态扩展，一开始申请内存时就无法获得足够内存，抛出OOM。
  * 解决方案：因为栈的容量是JVM的内存减去最大堆容量、最大方法区容量然后分配的。所以思路是减少最大堆或者减少栈容量来换取更多的线程。但是更容易爆栈了。

* 方法区溢出

  * 方法区溢出比较常见，因为类被垃圾回收器回收的条件挺苛刻的，在经常运行时生成大量动态类的场景中，需特别关注。

    

## 类加载机制



### 类加载的过程

* 加载：加载阶段，Java虚拟机需要完成三件事情。
* 验证：文件格式验证；元数据验证；字节码验证；符号引用验证
* 准备：正式为类变量分配内存并设置类变量初始值的阶段，仅限类变量；用final修饰的会直接赋值。
* 解析：虚拟机将常量池中的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。
  * 符号引用就是一组符号来描述目标，可以是任何字面量。
  * 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的
  * 举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。
* 初始化：执行初始化方法<clinit>()方法的过程，这一步才开始真正执行类中定义的Java程序代码。
* 卸载：卸载就是指该类的class对象被回收。
  * 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
  * 该类没有在其他任何地方被引用
  * 该类的类加载器的实例已被 GC
  * 所以说用JVM自带的类加载器的类是不会被卸载的。

### 类加载器

**Q：什么是类加载器**

将类的class文件字节码内容加载到内存中，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型



**Q：类加载器分类**

在JVM看来，只有两种类加载器。一种是启动类加载器（C++）；另一种是其他所有的类加载器（Java），独立于JVM外部，继承自ClassLoader

* 启动类加载器：C++写的，加载Java的核心类

* 扩展类加载器：加载JRE的扩展目录

* 应用程序类加载器：负责加载当前应用classpath下的所有jar包和类，也就是自己写的Java代码

  

**Q：双亲委派模型**

 自底向上检查类是否被加载；自顶向下尝试加载类

* 如果一个类加载器收到了类加载的请求，自己不会去尝试加载这个类，而是把请求委派给父类的加载器去完成，每一个层次的类加载都是如此。当父类的加载器无法加载时，子加载器才会尝试自己去完成。

* 好处：类的加载器也具备了像Java类一样的层次关系，无论哪一个类，最终都会委派给最顶端的启动类加载器去完成。比如Object类，在程序的各种类加载器环境中，都可以保证是同一个类；如果没有双亲委派模型，由各个类加载器自行加载，用户自己写一个Object类，放在程序的ClassPath中，系统就会出现多个不同的Object类，造成混乱。

  

**Q：如何设计自己的类加载器**

自定义加载器：需要继承 ClassLoader 。如果我们不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 loadClass() 方法。



**Q：为什么要打破双亲委派模型**

越基础的类由越上层的加载器进行加载，如果基础类又要调用回用户的代码，也就是说当父加载器加载的类需要用到子加载器加载的类，由于双亲委派机制的存在，此时就实现不了。

以JDBC为例，它是一个标准。不同的数据库厂商（如，mysql、oracle等）会根据这个标准，有它们自己的实现。 JDBC 的接口，就已经存在于JDK 中了。（JDBC 相关的接口存在与 rt.jar 的java.sql 包下）。因此，JDBC 相关的这些接口，在启动的时候，是由启动类加载器（boost classLoader）去加载的。而通常，我们会将数据库厂商提供的 jar 包放置在 classPath 下，由此可知，数据库厂商所提供的实现类不会由启动类加载器来去加载，它们通常是由系统类加载器来去加载的。这样一来，接口是有启动类加载器加载的，而具体的实现是由应用类加载器加载的。根据类的双亲委托原则，父加载器所加载的类/接口是看不到子加载器所加载的类/接口的，然而，子加载器所加载的类/接口是能够看到父加载器的类/接口的。这样的话，会导致这样一个局面：JDBC 相关的代码可能还需要去调用具体实现类中的代码，但是它是无法看到具体的实现类的（因为是由其子加载器加载的）。所以它用了线程上下文加载器来打破双亲委派模型。

Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。



**Q：如何打破双亲委派模型**

- 自定义类加载器，重写loadClass方法、findClass方法

- 使用线程上下文类加载器

  

### JDK监控和故障处理工具

* 指令

  *  jstat:见识虚拟机各种运行状态。它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据
  *  jmap：生成堆转储快照
  *  jstack：生成虚拟机当前时刻的线程快照。目的是定位线程长时间出现停顿的原因，如线程死锁、死循环、IO时间过长。查看等待时间过长的线程在等待什么。

* JDK可视化工具

  * Jconsole：在控制台输出console命令；或者在JDKbin目录下找到jconsole.exe启动；

    * 内存监控：显示当前内存的详细信息
    * 线程监控：类似于jstack命令，可以查看当前线程的运行状态。
